<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="小技巧 当我们写一个很大的数的时候,例如1000000000,十亿,在java中我们可以用下划线来切割 12int i &#x3D; 10_0000_0000;&#x2F;&#x2F;这样写就不容易写错了,这是JDK7的新特性  &#x2F;&#x2F;在idea中可以利用100.for的快捷输入来生成for循环次数为100的模板。 for (int i &#x3D; 0; i &lt; 100; i++) &amp;#123;  &amp;#125; &lt;!--he">
<meta property="og:type" content="article">
<meta property="og:title" content="java学习">
<meta property="og:url" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="lhf_siven">
<meta property="og:description" content="小技巧 当我们写一个很大的数的时候,例如1000000000,十亿,在java中我们可以用下划线来切割 12int i &#x3D; 10_0000_0000;&#x2F;&#x2F;这样写就不容易写错了,这是JDK7的新特性  &#x2F;&#x2F;在idea中可以利用100.for的快捷输入来生成for循环次数为100的模板。 for (int i &#x3D; 0; i &lt; 100; i++) &amp;#123;  &amp;#125; &lt;!--he">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20200930210910783.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20200930220555417.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20200930223720864.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201001114243391.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201001164928462.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201002105748251.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/1064302-20161230090438195-1243745647.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201011170335084.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201012155703227.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201022105815867.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201209204252185.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201209231444884.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201210223238882.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201211201854550.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201212205748029.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201212205519171.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201212221259163.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201229234031916.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201231213929030.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/20200325111818566.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208101126683.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208102041319.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208102205677.png">
<meta property="og:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208102444709.png">
<meta property="article:published_time" content="2020-09-22T13:18:49.000Z">
<meta property="article:modified_time" content="2020-12-31T14:54:28.425Z">
<meta property="article:author" content="lhf_siven">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20200930210910783.png">

<link rel="canonical" href="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>java学习 | lhf_siven</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">lhf_siven</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-22 21:18:49" itemprop="dateCreated datePublished" datetime="2020-09-22T21:18:49+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-31 22:54:28" itemprop="dateModified" datetime="2020-12-31T22:54:28+08:00">2020-12-31</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><ul>
<li><p>当我们写一个很大的数的时候,例如1000000000,十亿,在java中我们可以用下划线来切割</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="comment">//这样写就不容易写错了,这是JDK7的新特性</span></span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="java">//在idea中可以利用100.for的快捷输入来生成for循环次数为100的模板。
for (int i = 0; i &lt; 100; i++) &#123;

&#125;
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## JavaSE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 基础知识&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 特性和优势&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 简单性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 面向对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 可移植性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 高性能&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 分布式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 动态性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 多线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 安全性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 健壮性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### Java三大版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+  Write Once、Run Anywhere&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JavaSE：标准版（桌面程序，控制台开发）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JavaME：嵌入式开发（手机，小家电）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JavaEE：：E企业级开发（web端，服务器开发）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### JDK、JRE、JVM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JDK：Java Development Kit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JRE：Java Runtime Environment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JVM：Java Virtual Machine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;![image-20200923200112627](java学习&amp;#x2F;image-20200923200112627.png)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;根据上图可以看出三者之间的关系。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 卸载JDK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. 删除java的安装目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 删除JAVA_HOME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 删除path下关于java的目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. cmd下java -version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 安装JDK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;百度教程，下载JDK8就好了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### JAVA程序运行机制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 编译型(以看外文书为例,看之前先翻译好)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 解释性(请一个翻译员,看一句翻译一句)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 一般的语言的运行机制是上面的两种之一,二者各有好处,前者一次编译,执行效率就比较高,但是如果代码有所改动的话需要再次编译,而后者不需要但是后者的运行效率没那么高,因为是边执行边编译.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;![image-20200924150625592](java学习&amp;#x2F;image-20200924150625592.png)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java的运行机制是二者皆有,先编译成字节码,在通过解释器解释给操作系统&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;随着项目的规模扩张,我们有时候翻看之前的代码的时候可能会阅读的比较困难,因此注释的存在就很有必要了.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**java中的注释有三种**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 单行注释(&amp;#x2F;&amp;#x2F;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 多行注释(&amp;#x2F;**&amp;#x2F;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 文档注释(&amp;#x2F;**  *&amp;#x2F;,以&amp;#x2F;***开头)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 标识符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 关键字：Java中事先定义的，有特别意义的标识符，有时又叫保留字，关键字不能用作变量名、方法名、类名、包名和参数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ![image-20200925171124073](java学习&amp;#x2F;image-20200925171124073.png)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ Java中所有的组成部分都需要名字。类名、变量名以及方法名等都被称为标识符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 规则：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 所有的标识符都应该以字母、美元符号&amp;#39;$&amp;#39;、下划线&amp;#39;_&amp;#39;开始。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 首字母后可以是字母、美元符号、下划线、数字的任意字符组合。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 不能使用关键字作为变量名或方法名、类名。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 标识符是大小敏感的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 可以使用中文命名，但是一般不建议。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 数据类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**强类型语言**：要求变量的使用要严格符合规定，所有变量都必须先定义，才能够使用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**弱类型语言**：无需事先声明变量类型。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前者安全，后者效率高，各有取舍，对应了不同的应用场景。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**Java的数据类型分为两大类**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 基本数据类型（primitive type）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 数值类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    + 整数类型：byte：1字节，short：2字节，int：4字节，long：8字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    + 浮点类型：floate：4字节，double：8字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    + 字符类型：char：2字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + boolean类型：1个字节，只有false和true两个值。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 引用数据类型（reference type）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 数据类型扩展&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**整数扩展**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#96;&amp;#96;&amp;#96;java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;整数扩展: 进制  二进制0b   十进制 八进制0 十六进制0x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i0 &amp;#x3D; 0b10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i1  &amp;#x3D; 10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i2 &amp;#x3D; 010;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i3 &amp;#x3D; 0x10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(&amp;quot;&amp;quot;+i0+&amp;#39;\t&amp;#39;+i1+&amp;#39;\t&amp;#39;+i2+&amp;#39;\t&amp;#39;+i3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;输出:2    10    8    16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
</li>
</ul>
<p><strong>浮点数扩展</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    浮点数的存储形式决定了它只能是一个离散的值,与我们实际想要得到的值存在误差.</span></span><br><span class="line"><span class="comment">    因此我们应避免使用浮点数来进行比较,如果实在需要比较,那么需要也只能在某一个范围内比较,这个范围取决于精度,</span></span><br><span class="line"><span class="comment">    也就是误差能容忍的范围.</span></span><br><span class="line"><span class="comment">    但有些地方要求数据是很精确的,例如银行.</span></span><br><span class="line"><span class="comment">    此时我们就要使用BigDecimal,是Java中预设的一个数学工具类.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>字符扩展</strong></p>
<p>所有的字符本质还是数字,可以用(int)进行强制转换</p>
<p><strong>字符串扩展</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line">String s3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s4 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s3==s4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">造成这种输出差异的原因在于内存分配.</span></span><br><span class="line"><span class="comment">首先我们要知道s1,s2,s3,s4都是类对象,都是引用数据类型,它们指向了内存中的一块区域,而它们本身被存储在栈内存中.</span></span><br><span class="line"><span class="comment">对于s1和s2它们指向的内存是由new开辟出来的内存,位置在堆内存中,且相互独立.</span></span><br><span class="line"><span class="comment">而s3和s4指向的&quot;hello&quot;,则是被放在了常量池当中.</span></span><br><span class="line"><span class="comment">而引用类型的比较,是比较它们所指向的地址,因此s1==s2为false,s3==s4为true;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h4><p>栈区：存放局部变量（变量名，对象的引用等）特点：内存随着函数的调用而开辟，随着函数调用结束而释放。</p>
<p>堆区：存放对象（也就是new出来的东西）特点：可以跨函数使用，每个对象有自己对应的存储空间。</p>
<p>静态域：存放在对象中用static定义的静态成员。</p>
<p>常量池：存放常量。（常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。）</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li><p>由于Java是强类型语言,所以要进行有些运算的时候,需要用到类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//低 ---------------------------&gt; 高</span></span><br><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>-&gt;<span class="keyword">int</span>-&gt;<span class="keyword">long</span>-&gt;<span class="keyword">float</span>-&gt;<span class="keyword">double</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">+ <span class="keyword">byte</span> b = i; <span class="comment">//错误</span></span><br><span class="line">+ <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;<span class="comment">//正确</span></span><br><span class="line">+ <span class="keyword">boolean</span> b = (<span class="keyword">boolean</span>) i;<span class="comment">//错误    </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运算中，不同类型的数据先转化为同一类型，然后进行运算。</p>
</li>
<li><p>强制类型转换：（类型）变量名  高-&gt;低</p>
</li>
<li><p>自动类型转换：低 -&gt; 高</p>
</li>
<li><p>注意点</p>
<ol>
<li>不能对布尔值进行转换。</li>
<li>不能把对象类型转换为不相干的类型。</li>
<li>在把高容量转换到低容量的时候，强制转换。</li>
<li>转换到时候可能存在内存溢出，或者精度问题。 </li>
</ol>
</li>
</ul>
<ol start="5">
<li>short,byte,char等类型之间（包括同类型内）的运算,会自动转化成int型。</li>
</ol>
<ul>
<li>对于上面第4点的内存溢出,比较好想到的是大容量转化为低容量强制转换时的情况,但实际上低容量转化为大容量,自动转换是也有可能发生,但与前面的有些不同,举个例子:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">long</span> y = a*i;</span><br><span class="line">System.out.println(y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:-1474836480</span></span><br><span class="line"><span class="comment">//可以看出由于a和i都是int型,因此a*i是按4个字节来算的,因此结果溢出,在已经溢出的情况下转化为long,值依旧是不正确的.</span></span><br><span class="line"><span class="comment">//正确的做法应该是将a*i改成(long)a*i,让他们按long的规则来算.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>变量：可以变化的量。</li>
<li>Java是一种强类型语言，每个变量都必须声明其类型。</li>
<li>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type varName [=value] [&#123;,varName[=value]&#125;];</span><br><span class="line"><span class="comment">//数据类型    变量名 = 值;可以使用逗号隔开来声明多个同类型变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项:<ul>
<li>每个变量都有类型，类型可以是基本类型，也可以是引用类型。</li>
<li>变量名必须是合法的标识符。</li>
<li>变量声明是一条完整的语句，因此每一个声明都必须以分号结束。</li>
</ul>
</li>
</ul>
<p><strong>变量类型</strong></p>
<ul>
<li>类变量</li>
<li>实例变量</li>
<li>局部变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">variable</span></span>&#123;</span><br><span class="line">       <span class="comment">//下面这两个变量都是成员变量。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> allClicks = <span class="number">0</span>; <span class="comment">//类变量（由static关键字修饰）</span></span><br><span class="line">    String str;    <span class="comment">//实例变量，从属于对象；如果不自行初始话，会初始化为这个类型的默认值：0（整数类型），0.0（浮点数类型），u0000（字符类型），布尔值：默认是false；除了基本类型其余的默认值都是null；</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">//局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常量</strong></p>
<ul>
<li>常量（Constant）：初始化（initialize）后不能再改变值，不会变动的值。</li>
<li>所谓的常量可以理解成一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 常量名 = 值;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//常量用final关键字修饰.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常量名一般使用大写字符。</li>
</ul>
<p><strong>变量的命名规范</strong></p>
<ul>
<li>所有变量、方法、类名：<strong>见名知意</strong></li>
<li>类成员变量：首字母小写和驼峰原则（除了第一个单词以外，此后的所有单词首字母大写）：monthSalary</li>
<li>局部变量：首字母小写和驼峰原则</li>
<li>常量：大写字母和下划线：MAX_VALUE</li>
<li>类名：首字母大写和驼峰原则：Man，GoodMan(<strong>只有这个是首字母大写</strong>)</li>
<li>方法名：首字母小写和驼峰原则：run(),runRun()</li>
</ul>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul>
<li><p>Java语言支持如下运算符：</p>
<ul>
<li>算数运算符：+，-，*，/，%，++，–</li>
<li>赋值运算符：=</li>
<li>关系运算符：&gt;,&lt;,&gt;=,&lt;=,==,!= instanceof</li>
<li>逻辑运算符：&amp;&amp;，||，！</li>
<li>位运算符：&amp;，|，^，~，&gt;&gt;(/2)，&lt;&lt;(*2)，&gt;&gt;&gt;（了解）</li>
<li>条件运算符：? :</li>
<li>扩展运算符：+=，-=，*=，/=</li>
</ul>
</li>
<li><p>其他一些高级点的运算，例如幂运算，在Java中可以借用工具类Math中的pow(底数,指数)函数来实现，Math类中有很多实用的方法。</p>
</li>
</ul>
<h4 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h4><ul>
<li><p>为了更好地组织类，Java提供了包机制，用于区别类名的命名空间。</p>
</li>
<li><p>包语句的语法格式为：</p>
<p><code>package pkg1[. pkg2[. pkg3...]];</code></p>
</li>
<li><p>一般利用公司域名倒置作为包名；</p>
</li>
<li><p>为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包，使用“import”语句可以完成此功能。</p>
<p><code>import package[.package2...].(classname|*);</code></p>
</li>
<li><p>package必须放在最上面，import语句不能在它之前。</p>
</li>
</ul>
<h4 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h4><ul>
<li>JavaDoc命令是用来生成自己的API文档的（javadoc -encoding UTF-8 -charset UTF-8 package.xxx.java)</li>
<li>上面这个使用命令行生成javadoc,idea也有自带的方法生成,具体位置在tool-&gt;generate Javadoc,详细参数见百度.</li>
<li>参数信息<ul>
<li>@author 作者名</li>
<li>@version 版本号</li>
<li>since 指明需要最早使用的jdk版本（即多少版本后的jdk可以使用）</li>
<li>@param 参数名</li>
<li>@return 返回值情况</li>
<li>@throws 异常抛出情况</li>
</ul>
</li>
</ul>
<h4 id="Java流程控制"><a href="#Java流程控制" class="headerlink" title="Java流程控制"></a>Java流程控制</h4><hr>
<h4 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h4><ul>
<li><p><strong>java.util.Scanner使Java5的新特性,我们可以通过Scanner类来获取用户的输入。</strong></p>
<p><code>Scanner s = new Scanner(System.in);</code></p>
</li>
<li><p>通过Scanner类的next()与nextLine()方法获取输入的字符串,在读取前我们一般需要使用hasNext()与hasNextLine()判断是否还有输入的数据。</p>
</li>
<li><p>next():</p>
<ol>
<li>一定要读取到有效字符后才可以结束输入</li>
<li>对输入有效字符之前遇到的空白,next()方法会自动将其去掉</li>
<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符</li>
<li><strong>next()不能得到带有空格的字符串</strong></li>
</ol>
</li>
<li><p>nextLine():</p>
<ol>
<li>以Enter为空格符,也就是说nextLine()方法返回的使输入回车之前的所有字符（包括有效字符前的空白）</li>
<li>可以获得空白。</li>
</ol>
</li>
</ul>
<h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><ul>
<li>Java的基本结构就是顺序结构,除非特别指明,否则就按照顺序一句一句执行。</li>
<li>顺序结构使最简单的算法结构。</li>
<li>顺序结构使由若干个依次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构。</li>
</ul>
<h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><ul>
<li><p>if单选择结构    if(){}</p>
</li>
<li><p>if双选择结构    if(){}else{}</p>
</li>
<li><p>if多选择结构    if(){}else if(){}…else{}</p>
</li>
<li><p>嵌套的if结构    if(){if(){…}}</p>
</li>
<li><p>switch多选择结构：switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value <span class="number">2</span>:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch语句中的变量类型可以是：</p>
<ul>
<li>byte、short、int或者char</li>
<li>从JavaSE 7开始</li>
<li>switch支持字符串String类型</li>
<li>同时case标签必须为字符串常量或者字面量，具体实现是因为每个字符串的本质其实就是hashcode，也就是数字，我们可以通过将对应的class文件放入到java文件同目录下，可以通过idea自带的反编译功能，去观测到编译器为我们做的一些工作。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20200930210910783.png" alt="image-20200930210910783"></p>
<p>比如上图，我们可以看到当switch匹配字符串的时候，编译器其实将其转换成了对应hashcode的比较。 </p>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul>
<li><p>while循环    while(布尔表达式){}</p>
</li>
<li><p>do…while 循环 do{//代码语句}while(布尔表达式)；与while循环不同的是，do…while循环至少执行一次，前者是先判断后执行，后者是先执行后判断。</p>
</li>
<li><p>for循环</p>
<ul>
<li><p>for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。</p>
</li>
<li><p>for循环执行的次数是在执行前就确定的。语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化;布尔表达式;更新)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在idea中可以利用100.for的快捷输入来生成</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>最先执行初始化步骤，可以声明一种类型，但可以初始化一个或多个循环控制变量，也可以是空语句。布尔表达式和更新都可以是空语句，但这样的for循环就会变成了死循环。</p>
</li>
<li><p>在Java5中引入了一种主要用于数组的增强型for循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句:表达式)&#123;</span><br><span class="line">    <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break&amp;continue"></a>break&amp;continue</h4><ul>
<li><p>break：在任何循环语句的主体部分，均可用break控制循环的流程。break用于强制退出循环，不执行循环中的剩余的语句。（break语句也可在switch语句中使用）</p>
</li>
<li><p>continue：用在循环语句体中，用于终止某次循环过程，即跳过本次循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</p>
</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20200930220555417.png" alt="image-20200930220555417"></p>
<h3 id="Java方法详解"><a href="#Java方法详解" class="headerlink" title="Java方法详解"></a>Java方法详解</h3><hr>
<ul>
<li>Java方法是语句的集合，它们在一起执行一个功能。<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
</li>
<li>设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保证方法的原子性，<strong>就是一个方法只完成一个功能，这样有利于我们后期的扩展。</strong></li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20200930223720864.png" alt="image-20200930223720864"></p>
<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><ul>
<li>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</li>
<li>方法重载的规则：<ul>
<li>方法名称必须相同。</li>
<li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）</li>
<li>方法的返回类型可以相同也可以不同，不影响。</li>
</ul>
</li>
<li>实现理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li>
</ul>
<h4 id="可变参-不定项-数"><a href="#可变参-不定项-数" class="headerlink" title="可变参(不定项)数"></a>可变参(不定项)数</h4><ul>
<li>JDK1.5开始，Java支持传递同类型的可变参数给一个方法。</li>
<li>在方法声明中，在指定参数类型后加一个省略号(…)。</li>
<li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数都必须在它之前声明。</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201001114243391.png" alt="image-20201001114243391"></p>
<ul>
<li>感觉跟数组没什么差别。</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li>数组是相同类型数据的有序集合</li>
<li>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。</li>
<li>其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。</li>
</ul>
<p><strong>数组声明创建</strong></p>
<ul>
<li>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;    <span class="comment">//首选的方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[];    <span class="comment">//效果相同,但不是首选方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java语言使用new操作符来创建数组，语法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure>

<ul>
<li>数组元素是通过下标索引访问的,数组索引从0开始.</li>
<li>通过<code>arrays.length</code>我们可以获取数组长度。</li>
</ul>
<p><strong>三种初始化</strong></p>
<ul>
<li><p>静态初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Man[] mans = &#123;<span class="keyword">new</span> Man(<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">new</span> Man(<span class="number">2</span>,<span class="number">2</span>)&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的默认初始化</p>
<ul>
<li>数组是引用类型,它的元素相当于类的实例变量,因此数组一经分配空间,其中的每个元素页呗按照实例变量同样的方式被隐式初始化。</li>
</ul>
</li>
<li><p>数组的四个基本特点</p>
<ul>
<li>长度是确定的。数组一旦被创建，它的大小就是不可改变的。</li>
<li>数组内元素必须是相同类型，不允许出现混合类型。</li>
<li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li>
<li>数组变量属于引用类型，数组也可以看成对象，数组中的每个元素相当于该对象的成员变量。</li>
<li>数组本身就是对象，Java中对象实在堆中的，因此数组无论保存原始类型还是其他对象类型，<strong>数组对象本身是在堆中的</strong>。</li>
</ul>
</li>
<li><p>多维数组</p>
<ul>
<li><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其中每一个元素都是一个一维数组。</p>
</li>
<li><p>2*5的二维数组定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">5</span>]<span class="comment">//int[][] a也可以</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h4><ul>
<li>数组的工具类java.util.Arrays</li>
<li>虽然数组对象本身并没有什么方法可以供我们调用,但API中提供了一个工具类Arrays供我们使用,从而可以对数据对象进行一些基本的操作。</li>
<li><strong>具体查看JDK帮助文档</strong></li>
<li>Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而“不用”使用对象来调用(注意:是”不用”,而不是”不能”)</li>
<li>常用功能：<ul>
<li>给数组赋值：通过fill方法</li>
<li>对数组排序：通过sort方法，默认升序</li>
<li>比较数组：通过equals方法比较数组中的元素值是否相等。</li>
<li>查找数组元素：通过binarySearch方法能对排好序的数组进行二分查找操作。</li>
</ul>
</li>
</ul>
<h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201001164928462.png" alt="image-20201001164928462"></p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//简单实现下冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">       arr[x] = arr[x]^arr[y];</span><br><span class="line">       arr[y] = arr[x]^arr[y];</span><br><span class="line">       arr[x] = arr[x]^arr[y];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;end-<span class="number">1</span>;x++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[x]&gt;arr[x+<span class="number">1</span>])&#123;</span><br><span class="line">               swap(arr,x,x+<span class="number">1</span>);</span><br><span class="line">               b =<span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> b;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x = arr.length;x&gt;<span class="number">1</span>&amp;&amp;bubble(arr,x);x--);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h4><ul>
<li>当一个数组大部分元素为0,或者为同一值时,可以使用稀疏数组来保存该数组。</li>
<li>稀疏数组的处理方式时：<ul>
<li>记录数组一共有几行几列，有多少个不同值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。</li>
<li>如下图：左边时原始数组，右边是稀疏数族</li>
<li>稀疏数组的第0号元素记录了原始数组的行列以及有效值的个数，其他号元素对应了有效值的行列以及值的大小。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201002105748251.png" alt="image-20201002105748251"></p>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><hr>
<p><strong>Java的核心思想就是OOP</strong></p>
<ul>
<li>面向过程思想<ul>
<li>步骤清晰简单，第一步做什么，第二步做什么…</li>
<li>面向过程适合处理一些较为简单的问题</li>
</ul>
</li>
<li>面向对象思想<ul>
<li>物以类聚，<strong>分类</strong>的思维模式，思考问题首先会解决问题需要哪些类，然后对这些分类进行单独思考。最后才对某个类下的细节进行面向过程的思索。</li>
<li>面向过程适合处理复杂的问题，适合处理需要多人协作的问题！</li>
</ul>
</li>
<li><strong>对于描述复杂的事务，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</strong></li>
</ul>
<h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><ul>
<li>面向对象编程(Object-Oriented Programming,OOP)</li>
<li>面向对象编程的本质就是：以类的方式组织代码，以对象组织（封装）数据。</li>
<li>抽象</li>
<li>三大特性：<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
</li>
<li>从认识论角度考虑是先有对象后有类。对象是具体的事务。类，是对对象的抽象。</li>
<li>从代码运行角度考虑是现有类后有对象。类是对象的模板。</li>
</ul>
<h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4><ul>
<li>类是一种抽象的数据类型,它是对某一类事物的整体描述/定义,但是并不能代表某一个具体的事物.</li>
<li>对象是抽象概念的具体实例。</li>
</ul>
<h4 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h4><ul>
<li>使用<strong>new</strong>关键字创建对象</li>
<li>使用new关键字创建的时候，除了分配内存空间，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。</li>
<li>类种的构造器也称为构造方法，是在进行创建对象的时候必须调用的。并且构造器有以下特点：<ol>
<li>必须和类的名字相同</li>
<li>必须没有返回类型，也不能写void</li>
</ol>
</li>
<li></li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ol>
<li>静态方法和非静态方法：非static的函数可以调用static 的函数,但是static的函数不能够调用非static的函数,因为static的函数是对应类的，跟类一起加载,用类名即可调用，而非static的函数是对应于对象的，当对象new出来之后才能够调用。</li>
</ol>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul>
<li>该露的露，该藏的藏<ul>
<li>我们的程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</li>
</ul>
</li>
<li>封装（数据的隐藏）<ul>
<li>通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。</li>
</ul>
</li>
<li>属性私用，get/set。这样做能够</li>
</ul>
<p><strong>意义</strong></p>
<ol>
<li>提高程序的安全性，保护数据。例如在set方法中我们可以通过一些操作，规避掉一些不合理的数据。</li>
<li>隐藏代码的实现细节。</li>
<li>统一接口。</li>
<li>系统可维护性增加了。</li>
</ol>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>继承的本质是对一批类的抽象，从而实现对现实世界更好的建模。</li>
<li>extends的意思是扩展，子类是父类的扩展。</li>
<li>Java中类只有单继承，没有多继承。一个基类可以有多个派生类，但是一个派生类只能有唯一的一个基类</li>
<li>在Java中所有的类，都默认直接或间接的继承Object类。</li>
<li>继承是类和类之间的一种关系。除此之外，类和类之间还有诸如依赖、组合、聚合等关系。</li>
<li>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示。</li>
<li>子类和父类之间，从意义上讲应具有“is a”的关系</li>
<li>被final修饰的类不可被继承。</li>
</ul>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ol>
<li>super()可以用来调用父类的构造方法，但是必须写在子类构造方法的第一行。</li>
<li>在成员函数中我们也可以用super.method()来调用父类的方法，即使该方法被子类重写了。</li>
<li>super()和this()不能在构造方法中同时调用，因为它们都要求放在方法的第一行。</li>
<li>super类似this，不过它相当于一个可以调用父类属性或方法的权柄（前提是子类有这个访问权限，private的就无法调用）</li>
</ol>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul>
<li><p>重写都是方法的重写,和属性无关。</p>
</li>
<li><p>如果是静态的方法重写，方法的调用只与声明的数据类型有关。例如父类B和父类A中都存在静态的test方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B=&gt;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A=&gt;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">B b = <span class="keyword">new</span> A();</span><br><span class="line">a.test();</span><br><span class="line">b.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    A=&gt;test</span></span><br><span class="line"><span class="comment">    B=&gt;test</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分别调用的是A类和B类的test()方法,并没有多态的出现.如果把static去掉那么都为A=&gt;test.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重写vs重载</p>
<ul>
<li>方法的重载：在同一个类中，出现多个<strong>同名</strong>的方法，<strong>参数列表不同，与返回值类型，修饰符无关</strong></li>
<li>方法的重写：子类中出现和父类一模一样的方法（包括返回值类型，方法名，参数列表，访问权限可以不同，但是子类的重写的方法的访问权限要高于父类）</li>
</ul>
</li>
<li><p>注意事项：</p>
<ol>
<li>重写的方法必须要和父类一模一样（包括返回值类型，方法名，参数列表）</li>
<li>重写的方法可以使用@Override注解来标识</li>
<li>子类中重写的方法的访问权限不能低于父类中方法的访问权限。范围可以扩大,但是不能缩小。</li>
<li><strong>权限修饰符：private&lt;默认(什么都不写)&lt;protected&lt;public,事实上当父类方法为private时,子类对其并不可见,所以根本没有重写这一说,子类可以任意对编写相关同名方法.</strong></li>
<li>抛出的异常：范围与权限修饰符不同，可以被缩小，但不能被扩大。</li>
</ol>
</li>
<li><p>为什么需要重写：</p>
<ol>
<li>父类的功能，子类不一定需要，或者不一定满足。</li>
</ol>
</li>
</ul>
<h4 id="public-gt-protected-gt-default-gt-private"><a href="#public-gt-protected-gt-default-gt-private" class="headerlink" title="public &gt; protected &gt; (default) &gt; private"></a>public &gt; protected &gt; (default) &gt; private</h4><p>上面这四个关键字是Java中的权限修饰符，是实现Java封装特性的重要手段。</p>
<table>
<thead>
<tr>
<th>访问位置\修饰符</th>
<th>public</th>
<th>protected</th>
<th>(default)</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>可</td>
<td>可</td>
<td>可</td>
<td>可</td>
</tr>
<tr>
<td>同一个包</td>
<td>可</td>
<td>可</td>
<td>可</td>
<td>不可</td>
</tr>
<tr>
<td>不同包子类</td>
<td>可</td>
<td>可</td>
<td>不可</td>
<td>不可</td>
</tr>
<tr>
<td>不同包非子类</td>
<td>可</td>
<td>不可</td>
<td>不可</td>
<td>不可</td>
</tr>
</tbody></table>
<p>注意：(default)不是关键字“default”，而是指不写权限修饰符。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul>
<li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li>
<li>注意事项：<ol>
<li>多态是方法的多态，属性没有多态</li>
<li>存在条件：继承关系，方法需要重写，父类的引用指向子类对象。Father f1 = new Son（）；</li>
<li>不可被重写的方法：<ol>
<li>静态方法，属于类，不属于实例</li>
<li>final    常量，不能被更改</li>
<li>private方法    子类不可见</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><ul>
<li>这是一个java的一个操作符，从名字中我们就可以看出它的含义是：…的实例。它的作用便是如此，object instanceof class，可以用来判断这个object是否为该class的一个实例。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">person</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//我们都知道所有类都有一个共同的基类,那就是Object,因此继承关系如下:</span></span><br><span class="line"><span class="comment">//Object&gt;Person&gt;Student;Object&gt;Person&gt;Teacher</span></span><br><span class="line">Object object = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(object instance of Object);</span><br><span class="line">System.out.println(object instance of Person);</span><br><span class="line">System.out.println(object instance of Student);</span><br><span class="line">System.out.println(object instance of Teacher);</span><br><span class="line">System.out.println(object instance of String);</span><br><span class="line"><span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">    ture</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要注意的是,A instanceof B,编译的时候会看A的引用类型与B是否有关系,如果没关系那么直接报错,如果有关系,运行的时候,会根据A的实际类型,即其指向的对象的类型来判断A是否为B的一个实例,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//改成</span></span><br><span class="line">Student object = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//则下面语句会直接报错.</span></span><br><span class="line">System.out.println(object <span class="keyword">instanceof</span> Teacher);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译看左(引用类型),运行看右(对象类型),这点同样适用于多态,方法的调用,在编译期间看引用类型是否有这个方法,而运行期间实际调用取决于对象类型.</p>
</li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//代码块(匿名代码块),跟对象一起加载,在构造器之前执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//静态代码块,跟类一起加载,只执行一次，可以用来赋初值，但要注意的是它与类一起加载，因此它赋值的变量必须也是静态的，且该操作只会执行一次，切记。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="number">1.</span>&#123;&#125;</span><br><span class="line">        <span class="number">2.</span>&#123;<span class="keyword">new</span> Person();&#125;</span><br><span class="line">        <span class="number">3.</span>&#123;<span class="keyword">new</span> Person();<span class="keyword">new</span> Person();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    1.    静态代码块</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    2.    静态代码块    </span></span><br><span class="line"><span class="comment">        匿名代码块</span></span><br><span class="line"><span class="comment">        构造方法</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    3.    静态代码块</span></span><br><span class="line"><span class="comment">        匿名代码块</span></span><br><span class="line"><span class="comment">        构造方法</span></span><br><span class="line"><span class="comment">        匿名代码块</span></span><br><span class="line"><span class="comment">        构造方法</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment"> 1. 1情况下main方法为空语句,但依旧输出了&quot;静态代码块&quot;,且后面两种情况下都只出现一次静态代码块,由此可见静态代码块在类加载时期执行.且只执行一次</span></span><br><span class="line"><span class="comment"> 2. 根据2,3可以看出匿名代码块在构造方法之前执行,不是因为它写在构造方法之上,调换位置之后运行结果不变.且每次生成对象是都会调用该匿名代码块,因此它跟对象一起加载.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>static修饰的东西，无论是变量，函数亦或是代码块，或者内部类，都会变的与类挂钩，随类一起加载，可以由类名直接调用，切记，所有的对象实例都共享这些静态成员。</li>
<li>静态导入包：import static java.lang.Math.random;这样做可以将包中的一些方法，或者参数导入进来，可以不在通过类名调用。</li>
<li>注意不要把c++中的static代入进来，c++中static主要起一个隐藏的作用，而java中static表示成员与类挂钩。</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li><p><strong>abstract</strong>修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是<strong>抽象方法</strong>；如果修饰类，那么该类就是<strong>抽象类</strong>。</p>
</li>
<li><p><strong>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类</strong>。</p>
</li>
<li><p>抽象类,不能实例化对象,但是可以声明变量,用来关联它的子类。</p>
</li>
<li><p>抽象方法不能有方法体，只有声明，没有方法的实现，它是用来让子类实现的。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">([参数])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类继承抽象类,那么就必须实现抽象类没有实现的抽象方法,否则该子类也要声明为抽象类。</p>
</li>
<li><p>尽管抽象类不能实例化，但他依旧存在构造方法，该抽象方法仅用实例化子类是调用，本身不能用来实例化抽象类。</p>
</li>
<li><p>abstract不能与以下关键字共存：</p>
<ol>
<li>private    冲突 – 对子类隐藏,而 abstract 必须让子类</li>
<li>2.重写  final      冲突 – 不能被重写,矛盾  </li>
<li>static     无意义– 类名调用,没有方法体,无意义</li>
</ol>
</li>
<li><p><strong>为什么允许一个没有抽象方法的类可以是抽象类呢？</strong></p>
<p>因为我们要使得某些类不能被用来实例化,只能用来作为模板继承它本身,而这要求它是抽象的,但是有时候我们只想要实现该模板的某些功能，因为不知道每次使用的时候需要实现哪部分功能，因此这样的类通常定义了一组方法体为空的方法。</p>
<p>就以适配器类来说吧MouseAdapter是抽象类，但是没有抽象方法，<br>（如果他不是抽象的）直接实例化这个类没有没有任何意义，<br>既然我们需要使用这个类，就必然会覆盖某个方法，但又不知道是哪个方法，为了不让子类去重复实现一些他们不需要的方法，所以通常这种抽象类会将定义一系列方法体为空的方法。<br>使用者根据需要来覆盖方法，<br>一个没有抽象方法的抽象类一般来讲都会有诺干空的方法，这些方法不是必须要实现的，但是如果都不去实现这些方法，那这个类就没有什么意义了。</p>
</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范（抽象方法）都有</li>
<li>接口：只有规范！自己无法写法，专业的约束！约束和实现分离：面向接口编程。</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。例如：如果你是汽车，则必须能跑；如果你是学生，则必须会念书；</li>
<li>接口的本质是契约，就像我们人间的法律一样。制定好以后，大家都遵守。</li>
<li>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、java、c#等），就是因为设计模式所研究的，实际上就是如何合理的去抽象。声明类的关键字是class，声明接口的关键字是interface。</li>
<li>类中成员变量默认是包内可见，而接口中属性默认是public  static final的，方法默认是public abstract的，且只能是这样的，不可修改。</li>
<li>与类不同，接口允许多继承。</li>
<li>要注意的是extends必须写在implements的前面</li>
<li>接口可以继承多个接口.</li>
</ul>
<h4 id="接口VS抽象类"><a href="#接口VS抽象类" class="headerlink" title="接口VS抽象类"></a>接口VS抽象类</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/1064302-20161230090438195-1243745647.png" alt="img"></p>
<p><strong>什么时候使用抽象类和接口</strong></p>
<ul>
<li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li>
<li>如果你想实现多重继承，那么你必须使用接口。由于<strong>Java不支持多继承</strong>，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<h4 id="契约设计"><a href="#契约设计" class="headerlink" title="契约设计"></a>契约设计</h4><p>契约设计：类不会直接使用另外一个类，而是采用接口形式，外部可以“空投”任意实现了该接口的类。</p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ul>
<li></li>
<li>类别：<ol>
<li>成员内部类<ul>
<li>在类的内部定义,与实例变量、实例方法同级别的类。</li>
<li>外部类的一个实例部份，创建内部类对象时，必须依赖外部类对象。</li>
<li>成员内部类中不能定义静态成员，因为他的创建依赖于外部类对象，但是可以包含静态常量。</li>
</ul>
</li>
<li>静态内部类<ul>
<li>直接调用静态内部类，外部类不会加载。</li>
</ul>
</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ol>
</li>
<li>内部类和外部类的联系：</li>
</ul>
<ol>
<li><p><strong>内部类就是在一个类的内部再定义一个完整的类</strong>，比如，A类中定义一个B类，那么B类相对于A类来说就称为内部类，而A类相对于B类来说就是外部类了。</p>
</li>
<li><p>内部类对象的创建需要接助外部类对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Inner为Outer中的内部类</span></span><br><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line"><span class="comment">//内部类的对象需要由外部类的对象来new.</span></span><br><span class="line">Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类可以使用外部类的任何变量和方法，但是外部类必须要实例化内部类才可以使用内部类。<br>而且在实例化之前必须先创建一个外部类的实例。</p>
</li>
<li><p>如果内部类跟外部类出现了重名现象：</p>
<ul>
<li>内部类使用内部类的成员变量格式是: this.内部类成员变量名。</li>
<li>内部类使用外部类的成员变量格式是: 外部类名称.this.外部类成员变量名。</li>
<li>如果不显示表明，若在内部类中访问同名变量，则优先访问内部类中的变量。</li>
</ul>
</li>
<li><p><strong>外部类</strong>的访问权限只有两种：<strong>public和(default)。</strong><br>但是内部类因类型不同所以对应的访问权限也不一样。</p>
</li>
<li><p>编译之后内部类也会生成独立的字节码文件(Outer$Inner.class),上述四种内部类都会有。</p>
</li>
<li><p>内部类（不论是静态内部类还是非静态内部类）都是在第一次使用时才会被加载。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类方法&quot;</span>);</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匿名内部类,UserService是一个接口,</span></span><br><span class="line">        UserService us = <span class="keyword">new</span> UserService()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//内部类的对象需要由外部类的对象来new.</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常机制-Exception"><a href="#异常机制-Exception" class="headerlink" title="异常机制(Exception)"></a>异常机制(Exception)</h4><ul>
<li><p>Java 中的异常（Exception）又称为例外，是一个在程序执行期间发生的事件，它中断正在执行的程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类。</p>
</li>
<li><p>异常发生在程序运行期间，它影响了正常的程序执行流程。</p>
</li>
<li><p>要理解Java异常处理是如何工作的，需要掌握以下三种类型的异常：</p>
<ol>
<li>检查性异常（非运行时异常）：最具代表的检查性异常时用户错误操作引起的异常，这是程序员无法预见的。例如要打开一个不存在的文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略，必须做好相应的捕获处理。</li>
<li>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li>错误Error：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译时是检查不到的。</li>
</ol>
</li>
</ul>
<h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201011170335084.png" alt="image-20201011170335084"></p>
<p>上图只显示一些常见的异常。</p>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><ul>
<li>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</li>
<li>Java虚拟机运行错误（Virtural MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现<strong>OutOfMemoryError</strong>。这些异常发生时，Java虚拟机，一般会选择线程终止。</li>
<li>Error还可能发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外。</li>
</ul>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><ul>
<li>在Exception分支中有一个重要的子类：<strong>RuntimeException（运行时异常）</strong><ul>
<li>ArrayIndexOutOfBoundsException(数组下标越界)</li>
<li>NullPointerException(空指针异常)</li>
<li>ArithmeticException(算数异常)</li>
<li>MissingResourceException(丢失资源)</li>
<li>ClassNotFoundException(找不到类)等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。</li>
</ul>
</li>
<li>这些异常一般是由程序逻辑错误引起的，程序员应该从逻辑角度尽可能避免这类异常的发生。</li>
<li>Error和Exception的区别：Error通常是灾难性的致命性的错误，是程序无法控制和处理的，当出现这些异常时，JVM一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</li>
</ul>
<h4 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h4><ul>
<li>抛出异常</li>
<li>捕获异常</li>
<li>异常处理的五个关键字：try、catch、finally、throw、throws</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExpt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//try监控区域</span></span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;<span class="comment">//catch 捕获异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;devided by zero&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//可以捕获多个异常,范围较大的异常放在下头,因为一旦捕获了异常就不会在判断其他的catch了,所以为了让异常捕获更有针对性,所以当两个异常有继承关系的时候,更高级别的异常应该放到较后的顺序进行捕获. </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;<span class="comment">//处理善后工作,例如关闭IO资源等.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;一定会走&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以通过throw和throws来抛出异常,在方法中我们通过throw关键字主动抛出异常,也可以在方法头部通过throws关键字表示该方法处理不了某异常,可能会抛出某异常.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExpt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> TestExpt().test(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    haha</span></span><br><span class="line"><span class="comment">    处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可见当我们用throw关键字主动抛出异常时候,方法会立即结束.</strong></li>
</ul>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><ul>
<li>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需要继承Exception类即可。</li>
<li>在程序中使用自定义异常类，大体可分为以下几个步骤：<ol>
<li>创建自定义异常类。</li>
<li>在方法中通过throw关键字抛出异常对象。</li>
<li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li>
<li>在出现异常方法的调用者处捕获并处理异常。 </li>
</ol>
</li>
</ul>
<h4 id="实际应用中的经验总结"><a href="#实际应用中的经验总结" class="headerlink" title="实际应用中的经验总结"></a>实际应用中的经验总结</h4><ul>
<li>处理运行时异常时，采用逻辑去合理规避，同时辅以try-catch处理。</li>
<li>在多重catch块后面，可以加一个catch(Exception)来处理可能会被遗漏的异常。</li>
<li>对于不确定的代码，也可以加上try-catch，用来处理潜在的异常。</li>
<li>尽量去处理异常，切忌只是简单地调用printStackTrace()来打印异常信息。</li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定。</li>
<li>尽量添加finally语句块去释放占用的资源。</li>
</ul>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><hr>
<h4 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h4><ul>
<li>hashcode()</li>
<li>toString()</li>
<li>clone()</li>
<li>getClass()</li>
<li>notify()</li>
<li>wait()</li>
<li>equals()</li>
</ul>
<h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><ul>
<li>常见的数学运算</li>
</ul>
<h4 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h4><ul>
<li>生成随机数    UUID</li>
</ul>
<h4 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h4><ul>
<li>创建文件</li>
<li>查看文件</li>
<li>修改文件</li>
<li>删除文件</li>
</ul>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>自动装箱和拆箱.</p>
<h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><ul>
<li>Date</li>
<li>SimpleDateFormat  yyyy-mm-dd HH:MM:SS</li>
<li>Calendar(建议使用)</li>
</ul>
<h4 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h4><ul>
<li>不可变性 final</li>
<li>适用于操作量较少的情况</li>
</ul>
<h4 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h4><ul>
<li>可变长    append()</li>
<li>适用于多线程数据量较大的情况</li>
<li>效率低但安全</li>
</ul>
<h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><ul>
<li>可变长</li>
<li>适用于单线程数据量较大</li>
<li>效率高,不安全</li>
</ul>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><hr>
<h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><ul>
<li><p>Collection</p>
<ul>
<li>List(有序可重复)<ul>
<li>ArrayList </li>
<li>LinkedList</li>
<li>Vector</li>
<li>Stack </li>
</ul>
</li>
<li>Set(无需不可重复)<ul>
<li>HashSet</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li>HashMap</li>
<li>TreeMap</li>
</ul>
</li>
<li><p>Collections工具类</p>
</li>
<li><p>泛型&lt;&gt;约束,避免类型转换之间的问题</p>
</li>
<li><p>子主题</p>
</li>
</ul>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul>
<li>add</li>
<li>remove</li>
<li>contains</li>
<li>size  </li>
</ul>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>getFirst()</li>
<li>getLast()</li>
<li>removeFirst()</li>
<li>addFirst()</li>
</ul>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><h4 id="HashMap-重点"><a href="#HashMap-重点" class="headerlink" title="HashMap(重点)"></a>HashMap(重点)</h4><p>JDK1.7：数组+链表</p>
<p>JDK1.8：hash表 = 数组+链表+红黑树</p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><hr>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><hr>
<ul>
<li>程序：程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。</li>
<li>进程：是程序的一次执行过程，是一个动态的概念。是系统分配资源的最小单位。</li>
<li>线程：通常在一个进程中可以包含若干个线程，当然一个进程至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的基本单位。</li>
<li>注意：很多多线程是模拟出来的，真正的多线程是指由多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，只是因为切换的速度很快，所以就产生了同时执行的错觉。</li>
<li>对同一份资源操作时，会存在资源抢夺问题，需要加入并发控制。</li>
<li>线程会带来额外的开销，如CPU调度时间，并发控制开销。</li>
</ul>
<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201012155703227.png" alt="image-20201012155703227"></p>
<h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><ul>
<li>自定义线程类继承Thread类</li>
<li>重写run()方法，编写线程执行体。</li>
<li>创建线程对象，调用start()方法启动线程。</li>
<li>线程不一定立即执行，这取决于操作系统的CPU调度 </li>
</ul>
<h4 id="案例：下载图片"><a href="#案例：下载图片" class="headerlink" title="案例：下载图片"></a>案例：下载图片</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Thread;</span><br><span class="line"><span class="comment">//导了一个apache的jar包</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String URL;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebDownloader</span><span class="params">(String URL,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.URL = URL;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Downloader downloader = <span class="keyword">new</span> Downloader();</span><br><span class="line">        downloader.download(URL,name);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载完成: &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WebDownloader webDownloader1 = <span class="keyword">new</span> WebDownloader(URL1, <span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        WebDownloader webDownloader3 = <span class="keyword">new</span> WebDownloader(URL2, <span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line">        WebDownloader webDownloader2 = <span class="keyword">new</span> WebDownloader(URL3, <span class="string">&quot;3.jpg&quot;</span>);</span><br><span class="line">        webDownloader3.start();</span><br><span class="line">        webDownloader2.start();</span><br><span class="line">        webDownloader1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downloader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String URL,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(URL),<span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;IO异常: Downloader|&quot;</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><ul>
<li>定义MyRunnable实现Runnable接口</li>
<li>实现run()方法,编写线程执行体</li>
<li>创建线程对象,调用start()方法启动线程.</li>
<li>大多数情况下，如果只想重写 <code>run()</code> 方法，而不重写其他 <code>Thread</code> 方法，那么应使用 <code>Runnable</code> 接口。这很重要，因为除非程序员打算修改或增强类的基本行为，否则不应为该类创建子类。</li>
</ul>
<p><strong>建议实现Runnable接口,可避免单继承局限性,灵活方便,且方便同一个对象被多个线程使用,即一份资源,多个代理.</strong></p>
<h4 id="初识并发问题"><a href="#初识并发问题" class="headerlink" title="初识并发问题"></a>初识并发问题</h4><p>上面提到了实现Runnable接口之后,能够让同一个对象被多个线程使用,由于资源只有一份,所以多个线程同时操作的情况下,容易出现线程不安全,数据紊乱的情况,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lhf_siven.demo.TestExpt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;拿到了第&quot;</span>+num--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread1 testThread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        <span class="keyword">new</span> Thread(testThread1,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testThread1,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testThread1,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    A拿到了第10张票</span></span><br><span class="line"><span class="comment">    C拿到了第9张票</span></span><br><span class="line"><span class="comment">    B拿到了第10张票</span></span><br><span class="line"><span class="comment">    C拿到了第8张票</span></span><br><span class="line"><span class="comment">    A拿到了第7张票</span></span><br><span class="line"><span class="comment">    B拿到了第8张票</span></span><br><span class="line"><span class="comment">    C拿到了第6张票</span></span><br><span class="line"><span class="comment">    B拿到了第5张票</span></span><br><span class="line"><span class="comment">    A拿到了第4张票</span></span><br><span class="line"><span class="comment">    C拿到了第3张票</span></span><br><span class="line"><span class="comment">    A拿到了第2张票</span></span><br><span class="line"><span class="comment">    B拿到了第1张票</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上面这串代码我们模拟了三个线程同时抢票的过程,三个线程共享一个TestThread对象,从输出中我们可以发现,有某些票同时被几个线程所持有,这显然不是我们想要的,一张票理应只能由一个线程所持有。要想解决这一点就得用到线程同步。</p>
<h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">//可返回结果并且可能抛出异常的任务。实现者定义了一个不带任何参数的叫做 <span class="title">call</span> 的方法。<span class="title">Callable</span> 接口类似于 <span class="title">Runnable</span>，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 <span class="title">Runnable</span> 不会返回结果，并且无法抛出经过检查的异常。</span></span><br><span class="line">//注意:V不能是基本类型,必须是Object,如果实在要返回基本类型,那可以改成对应的包装类.</span><br></pre></td></tr></table></figure>



<ol>
<li>实现Callable接口,需要返回值类型</li>
<li>重写call方法,可以抛出异常</li>
<li>创建目标对象</li>
<li>创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);</li>
<li>提交执行：Future<Boolean> result1 = ser.submit(t1);</Boolean></li>
<li>获取结果：boolean r1 = result1.get()</li>
<li>关闭服务：ser.shutdownNow();</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把之前的下载图片,改成了用Callable的做法.</span></span><br><span class="line"><span class="keyword">package</span> com.lhf_siven.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Downloader downloader = <span class="keyword">new</span> Downloader();</span><br><span class="line">        downloader.download(url,name);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载完成: &quot;</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable(URL1);</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable(URL2);</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable(URL3);</span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        Future&lt;Boolean&gt; r1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; r2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; r3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        ser.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downloader1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String URL,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(URL),<span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;IO异常: Downloader|&quot;</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h4><ul>
<li>真实对象和代理对象都要实现同一个接口</li>
<li>代理角色要代理真实角色</li>
</ul>
<p>好处：</p>
<ul>
<li>代理对象可以做很多真实对象做不了的事情</li>
<li>真实对象可以专注做自己的事情。</li>
</ul>
<p>运用到了接口的解耦性。</p>
<p>在多线程中我们运用代理模式，因为Thread实现了Runnable接口，我们只要写一个实现了Runnable接口的匿名类即可,我们只要关注run方法该如何实现,而Thread为我们提供了很多别的帮助。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;    ... &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">           </span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;haha&quot;</span>));还有这种写法</span><br></pre></td></tr></table></figure>

<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><ul>
<li><p>λ是希腊字母表中排序第是一位的字母,英语名称为Lambda</p>
</li>
<li><p>其实质数于函数式编程的概念</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(params) -&gt; expression[表达式]</span></span><br><span class="line"><span class="comment">(params) -&gt; statement[语句]</span></span><br><span class="line"><span class="comment">(params) -&gt; &#123;statements&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line">a -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>+a);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在多线程编程时我们就可以运用Lambda表达式,而减少匿名内部类的定义,格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;statements&#125;).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么要使用lambda表达式</p>
<ul>
<li>避免匿名内部类定义过多</li>
<li>可以让你的代码看起来很简洁</li>
<li>去掉了一堆不太关键的逻辑</li>
</ul>
</li>
<li><p>理解Functional Interface(<strong>函数式接口</strong>)式学习Java8 lambda表达式的关键所在</p>
</li>
<li><p>函数式接口的定义:</p>
<ul>
<li>任何接口,如果指包含<strong>唯一一个抽象方法</strong>,那么它就是一个函数式接口。</li>
<li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象，也就是说上面()-&gt;{}就等价于实现了一个接口并创建了相应的对象,因此把它赋值给对应的接口变量,例如Demo demo = ()-&gt;{};这个语句就是把一个Demo接口实现,创建了相应对象并赋值给了demo变量.。 </li>
<li>注意lambdea只能用于函数时接口,而不能用于只有一个抽象方法的抽象类。</li>
<li>如果某函数式接口</li>
</ul>
</li>
</ul>
<h4 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201022105815867.png" alt="image-20201022105815867"></p>
<h4 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h4><ul>
<li>不推荐使用JDK提供的stop()、destroy()方法。【已废弃】</li>
<li>推荐让线程自己停止下来</li>
<li>建议使用一个标志位进行终止变量，例若flag=false，终止线程运行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在主线程控制标志位flag,决定子线程是否停止.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> judge = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(judge) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run...Thread&quot;</span> + i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.judge = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadStop threadStop = <span class="keyword">new</span> ThreadStop();</span><br><span class="line">        <span class="keyword">new</span> Thread(threadStop).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5000000</span>) &#123;</span><br><span class="line">                threadStop.stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程停止======&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="线程休眠（Sleep）"><a href="#线程休眠（Sleep）" class="headerlink" title="线程休眠（Sleep）"></a>线程休眠（Sleep）</h4><ul>
<li>sleep(时间):指定当前线程阻塞的<strong>毫秒数</strong>;</li>
<li>sleep存在异常InterruptedException;</li>
<li>sllep时间达到后线程进入<strong>就绪状态</strong>;</li>
<li>sleep可以用来模拟网络延迟,倒计时等,如下。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date Startdate = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(Startdate));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Startdate = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>每一个对象都有一个锁，sleep不会释放锁；</strong></li>
</ul>
<h4 id="线程礼让（Yield）"><a href="#线程礼让（Yield）" class="headerlink" title="线程礼让（Yield）"></a>线程礼让（Yield）</h4><ul>
<li>礼让线程,让当前正在执行的线程暂停,但不阻塞</li>
<li>将线程从运行状态转为就绪状态</li>
<li><strong>让cpu重新调度,礼让不一定成功!由cpu决定。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;A-&gt;Start&quot;</span>);</span><br><span class="line">    Thread.yield();</span><br><span class="line">    System.out.println(<span class="string">&quot;A-&gt;End&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;B-&gt;Start&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;B-&gt;End&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h4 id="线程强制执行（Join）"><a href="#线程强制执行（Join）" class="headerlink" title="线程强制执行（Join）"></a>线程强制执行（Join）</h4><ul>
<li><strong>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程转为阻塞</strong>。</li>
<li>可以简单将Join理解为插队。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不插队多半Main跑完A才跑,但是有了join,可以保证Main执行到50的时候,执行A,知道A线程执行完,主线程才继续执行.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo(),<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Main-&gt;&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">50</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;A========&quot;</span>);</span><br><span class="line">                t1.start();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h4><ul>
<li><p>Thread.State</p>
<p>线程可以处于以下状态之一：</p>
<ul>
<li>NEW：尚未启动的线程处于此状态。</li>
<li>RUNNABLE：在Java虚拟机中执行的线程处于此状态。</li>
<li>BLOCKED：被阻塞等待监视器锁定的线程处于此状态</li>
<li>WAITING：正在等待另一个线程执行特定动作的线程处于此状态。</li>
<li>TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</li>
<li>TERMINATED：已退出的线程处于此状态</li>
</ul>
<p><strong>一个线程可以在给定时间点处于某一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) </span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line">        thread.start();</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        <span class="keyword">while</span>(state != Thread.State.TERMINATED)&#123;</span><br><span class="line">            System.out.println(state);</span><br><span class="line">            state = thread.getState();</span><br><span class="line">            <span class="keyword">try</span> &#123; thread.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(state);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">        NEW</span></span><br><span class="line"><span class="comment">        RUNNABLE</span></span><br><span class="line"><span class="comment">        RUNNABLE</span></span><br><span class="line"><span class="comment">        TIMED_WAITING</span></span><br><span class="line"><span class="comment">        TERMINATED</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程,线程调度器按照优先级决定应该调度哪个线程来执行。</p>
</li>
<li><p>线程的优先级用数字表示，范围1~10。</p>
<ul>
<li>Thread.MIN_PRIORITY = 1;</li>
<li>Thread.MAX_PRIORITY = 10;</li>
<li>Thread.NORM_PRIORITY = 5;（默认）</li>
</ul>
</li>
<li><p>使用以下方式改变或获取优先级</p>
<p>getPriority()    setPriority(int)</p>
</li>
<li><p>优先级低只是意味着获得调度的概率低，但并不意味着优先级低的就一定是最后被调用，由cpu决定。</p>
</li>
<li><p>优先级的设定建议在start()调度前。</p>
</li>
</ul>
<h4 id="守护-daemon-线程"><a href="#守护-daemon-线程" class="headerlink" title="守护(daemon)线程"></a>守护(daemon)线程</h4><ul>
<li>线程分为用户线程和守护线程</li>
<li>虚拟机必须确保用户线程执行完毕</li>
<li>如：后台记录操作日志、内存监控、垃圾回收等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        You you = <span class="keyword">new</span> You();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        thread1.setDaemon(<span class="keyword">true</span>);<span class="comment">//默认false,表示是用户进程,正常的进程都是用户进程!</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(you).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上帝保佑着你=====&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你一生都开心的活着======&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;GoodBye=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果不将上帝线程设置为守护线程,那么这个程序会一直循环的跑下去知道程序崩溃,因为虚拟机要确保用户线程执行完毕,而一旦我们将其设置为守护线程,那么虚拟机是不会去管他是否执行完毕的,当所有用户线程执行完毕之后,虚拟机就会结束执行,守护线程也会随着结束。</strong></p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul>
<li><p>现实生活中，我们会遇到“同一个资源，多个人都想使用”的问题，例如：食堂排队打饭，每个人都想吃饭，最天然的解决办法就是—排队，一个个来。</p>
</li>
<li><p>处理多线程问题是，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的<strong>等待池</strong>形成队列，等待前面线程使用完毕，下一个线程再使用。</p>
</li>
<li><p><strong>线程同步形成条件：队列+锁</strong></p>
</li>
<li><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确行，java在访问时加入了<strong>锁机制synchronized</strong>，当一个线程获得对象的排它锁，则独占资源，其他线程必须等待。存在以下问题：</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起；</li>
<li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。  </li>
</ul>
</li>
</ul>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><hr>
<h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><hr>
<h3 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h3><hr>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li><p>Annotation是从JDK5.0开始引入的新技术。</p>
</li>
<li><p>Annotation的作用：</p>
<ul>
<li>不是程序本身，可以对程序做出解释（这一点与注释（commment）没什么区别）</li>
<li><strong>可以被其他程序（例如：编译器）读取。</strong></li>
</ul>
</li>
<li><p>Annotation的格式：</p>
<ul>
<li>注解是以**@注释名**在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings（value = “unchecked”）</li>
</ul>
</li>
<li><p>Annotation在哪里使用？</p>
<ul>
<li>可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。</li>
</ul>
</li>
</ul>
<h4 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h4><ul>
<li>@Override：定义在java.langOverride中,此注释只适用于修辞方法,表示一个方法声明打算重写超类中的另一个方法声明。</li>
<li>@Deprecated：定义在java.lang.Deprecated中,此注释可以用于修饰方法,属性,类,表示不鼓励程序员使用这样的元素,通常是因为它很危险或者存在更好的选择。</li>
<li>@SuppressWarnings(镇压警告)：定义在java.lang.SuppressWarnings中,用来抑制编译时的警告信息。<strong>与前面两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性地使用就好了。</strong><ul>
<li>@SuppressWarnings（“all”）</li>
<li>@SuppressWarnings（“unchecked”）</li>
<li>@SuppressWarnings（value={“unchecked”，”deprecation“}）</li>
<li>等等…</li>
</ul>
</li>
</ul>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul>
<li>元注解的作用就是负责注解其他注解，Java定义了4个标准的mata-annotation类型，他们被用来提供对其他annotation类型作说明。</li>
<li>这些类型和他们所支持的类在java.lang.annotation包中可以找到。（@Target，@Retention，@Documented，@Inherited）<ul>
<li>@Target：用于描述注解的适用范围（即：被描述的注解可以用在什么地方）</li>
<li>@Retention：表示需要在什么级别保存该注释 信息，用于描述注解的生命周期（SOURCE&lt;CLASS&lt;<strong>RUNTIME</strong>）</li>
<li>@Document：说明该注解将被包含在javadoc中</li>
<li>@Inherited：说明子类可以继承父类中的该注解。</li>
</ul>
</li>
</ul>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><ul>
<li>使用@interface自定义注解时，自动挤成了java.lang.annotation.Annotation接口</li>
<li>分析：<ul>
<li>@interface用来声明一个注解，格式：<code>[public] @interface 注解名&#123;定义内容&#125;</code></li>
<li>其中的每一个方法实际上是声明了一个配置参数。</li>
<li>方法的名称就是参数的名称。</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型：Class、String、enum）。</li>
<li>可以通过default来声明参数的默认值。</li>
<li>如果只要一个参数成员，一般参数名为value,这样在赋实参的时候可以省略<code>value = </code>。</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串、0做默认值。 </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="comment">//注解的参数:参数类型 + 参数名();</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    String[] school()<span class="keyword">default</span> <span class="string">&quot;山东大学&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反射（Reflection）"><a href="#反射（Reflection）" class="headerlink" title="反射（Reflection）"></a>反射（Reflection）</h3><hr>
<h4 id="静态VS动态用语言"><a href="#静态VS动态用语言" class="headerlink" title="静态VS动态用语言"></a>静态VS动态用语言</h4><p><strong>动态语言</strong></p>
<ul>
<li><p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p>
</li>
<li><p>主要的动态语言：Object-C、C#、JavcScript、PHP、Python等。</p>
</li>
</ul>
<p><strong>静态语言</strong></p>
<ul>
<li>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</li>
<li>Java不是动态语言，但是Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让程序员编程的时候可以更加灵活！</li>
</ul>
<h4 id="Java-Reflection"><a href="#Java-Reflection" class="headerlink" title="Java Reflection"></a>Java Reflection</h4><ul>
<li><p>Reflection(反射)是Java被视为准动态语言的关键,反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息,并能直接操作任意对象的内部属性及方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载完类之后,在堆内存的方法区中就产生了一个Class类型的对象(<strong>一个类只有一个Class对象，一个类被加载后，类的整个结构都会被封装在Class对象中。</strong>)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子能够看到类的结构，所以，我们形象的称之为：反射。</p>
</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201209204252185.png" alt="image-20201209204252185"></p>
<h4 id="Java反射机制提供的功能"><a href="#Java反射机制提供的功能" class="headerlink" title="Java反射机制提供的功能"></a>Java反射机制提供的功能</h4><ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任何一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
<li>…… </li>
</ul>
<h4 id="Java反射的优点和缺点"><a href="#Java反射的优点和缺点" class="headerlink" title="Java反射的优点和缺点"></a>Java反射的优点和缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>可以实现动态创建对象和编译，体现出很大的灵活性。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且要求它满足我们的请求。这类操作总是慢于直接执行相同的操作。</li>
</ul>
<h4 id="反射相关的主要API"><a href="#反射相关的主要API" class="headerlink" title="反射相关的主要API"></a>反射相关的主要API</h4><ul>
<li><p>java.lang.Class：代表一个类</p>
</li>
<li><p>java.lang.reflect.Method：代表类的方法</p>
</li>
<li><p>java.lang.reflect.Field：代表类的成员变量</p>
</li>
<li><p>java.lang.reflect.Constructor：代表类的构造器</p>
</li>
<li><p>……</p>
</li>
</ul>
<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201209231444884.png" alt="image-20201209231444884"></p>
<p>在Object类中定义了以下的方法，此方法将被所有子类继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title">getClass</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上的方法返回值的类型是一个Class类,此类是Java反射的源头,实际上所谓反射从程序的运行结果来看也很好理解,即：可以通过对象反射求出类的名称。</li>
</ul>
<h5 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象?"></a>哪些类型可以有Class对象?</h5><ul>
<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组(从下面的例子可以看出,无论数组多长,一种类型的数组只对应一个Class对象)</li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class c1 = Object.class;    //类</span><br><span class="line">    Class c2 = Comparable.class;//接口</span><br><span class="line">    Class c3 = String[].class;  //一维数组</span><br><span class="line">    Class c4 = <span class="keyword">int</span> [][].class;  //二维数组</span><br><span class="line">    Class c5 = Override.class;  //注解</span><br><span class="line">    Class c6 = ElementType.class;//枚举</span><br><span class="line">    Class c7 = <span class="keyword">void</span>.class;      //<span class="keyword">void</span></span><br><span class="line">    Class c8 = <span class="keyword">int</span>.class;       //基本数据类型</span><br><span class="line">    Class c9 = Integer.class;   //包装器类</span><br><span class="line">    Class c10 = Class.class;    //Class</span><br><span class="line">    System.out.println(c1);</span><br><span class="line">    System.out.println(c2);</span><br><span class="line">    System.out.println(c3);</span><br><span class="line">    System.out.println(c4);</span><br><span class="line">    System.out.println(c5);</span><br><span class="line">    System.out.println(c6);</span><br><span class="line">    System.out.println(c7);</span><br><span class="line">    System.out.println(c8);</span><br><span class="line">    System.out.println(c9);</span><br><span class="line">    System.out.println(c10);</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    System.out.println(a.getClass().hashCode());</span><br><span class="line">    System.out.println(b.getClass().hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">    class java.lang.Object</span></span><br><span class="line"><span class="comment">    interface java.lang.Comparable</span></span><br><span class="line"><span class="comment">    class [Ljava.lang.String;</span></span><br><span class="line"><span class="comment">    class [[I</span></span><br><span class="line"><span class="comment">    interface java.lang.Override</span></span><br><span class="line"><span class="comment">    class java.lang.annotation.ElementType</span></span><br><span class="line"><span class="comment">    void</span></span><br><span class="line"><span class="comment">    int</span></span><br><span class="line"><span class="comment">    class java.lang.Integer</span></span><br><span class="line"><span class="comment">    class java.lang.Class</span></span><br><span class="line"><span class="comment">    356573597</span></span><br><span class="line"><span class="comment">    356573597</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>只要元素类型与维度一样(例:一维数组跟二维数组对应的是两个不同的Class),就是同一个Class对象</strong>\</p>
<h4 id="类加载内存分析"><a href="#类加载内存分析" class="headerlink" title="类加载内存分析"></a>类加载内存分析</h4><h5 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h5><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201210223238882.png" alt="image-20201210223238882"></p>
<h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p>当程序主动使用某个类时,如果该类还未被加载到内存中,则系统会通过如下三个步骤来对该类进行初始化.</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201211201854550.png" alt="image-20201211201854550"></p>
<h4 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h4><ul>
<li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象。</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul>
</li>
<li>初始化：<ul>
<li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中<strong>所有类变量的赋值动作和静态代码块中的语句合并产生的（执行顺序为代码的先后顺序），因此这两部分内容在程序的运行周期中只会运行一次</strong>。（类构造器是构造类信息的，不是构造该类对象的构造器)</clinit></clinit></li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</clinit></li>
</ul>
</li>
</ul>
<h4 id="什么时候会发生类初始化？"><a href="#什么时候会发生类初始化？" class="headerlink" title="什么时候会发生类初始化？"></a>什么时候会发生类初始化？</h4><ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，若其父类没有被初始化，则先会初始化它的父类</li>
</ul>
</li>
<li>类的被动引用（不会发生类的初始化）<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化。</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（因为常量在链接阶段就存入调用类的常量池中了，所以说加载-链接-初始化并不一定是三个过程都要完成）</li>
</ul>
</li>
<li>如果只是单单声明了变量，并不会引发类的加载。</li>
</ul>
<h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><ul>
<li><p>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。JVM规范定义了如下类型的加载器：</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201212205748029.png" alt="image-20201212205748029"><br>核心库是jre里头的rt.jar(rt=runtime)</p>
</li>
<li><p>类缓存：标准的JavaSE类加载器可以按要求查找类，但<strong>一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</strong>。</p>
</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201212205519171.png" alt="image-20201212205519171"></p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201212221259163.png" alt="image-20201212221259163"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取系统类加载器</span></span><br><span class="line">    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader);</span><br><span class="line">    <span class="comment">//获取系统类加载器的父类加载器---&gt;扩展类加载器</span></span><br><span class="line">    ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">    System.out.println(parent);</span><br><span class="line">    <span class="comment">//获取扩展类加载器的父类加载器---&gt;根(引导类)加载器(c/c++),该加载器无法直接获取,所以输出的值为null</span></span><br><span class="line">    ClassLoader parent1 = parent.getParent();</span><br><span class="line">    System.out.println(parent1);</span><br><span class="line">    <span class="comment">//测试当前类是哪个加载器加载的</span></span><br><span class="line">    Class c1 = Class.forName(<span class="string">&quot;com.lhf_siven.Reflection.Test04&quot;</span>);</span><br><span class="line">    System.out.println(c1.getClassLoader());</span><br><span class="line">    <span class="comment">//测试Object类是哪个加载器加载的</span></span><br><span class="line">    System.out.println(Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">    sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">    sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>双亲委派机制：防止同名包、类与 jdk 中的相冲突，实际上加载类的时候，先通知 appLoader，看 appLoader 是否已经缓存，没有的话，appLoader 又委派给他的父类加载器(extLoader)询问，看他是不是能已经缓存加载,没有的话，extLoader 又委派他的父类加载器(bootstrapLoader)询问，BootstrapLoader看是不是自己已缓存或者能加载的，有就加载，没有再返回 extLoader，extLoader 能加载就加载，不能的话再返回给 appLoader 加载，再返回的路中，谁能加载，加载的同时也加缓存里。正是由于不停的找自己父级，所以才有 Parents 加载机制，翻译过来叫 双亲委派机制。 </li>
</ul>
<h4 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h4><p>通过反射获取运行时类的完整结构</p>
<p>Field、Method、Constructor、Superclass、Interface、Annotation</p>
<ul>
<li><p>实现的全部接口</p>
</li>
<li><p>所继承的父类</p>
</li>
<li><p>全部的构造器</p>
</li>
<li><p>全部的方法</p>
</li>
<li><p>全部的Field</p>
</li>
<li><p>注解</p>
</li>
<li><h6 id="……"><a href="#……" class="headerlink" title="……"></a>……</h6></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.lhf_siven.Reflection.User&quot;</span>);</span><br><span class="line">        <span class="comment">//获得类的名字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        System.out.println(c1.getName());   <span class="comment">//获得包名+类名</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">//获得类名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        <span class="comment">//获得类的属性</span></span><br><span class="line">        Field[] f1 = c1.getFields();    <span class="comment">//只能找到public属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : f1) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        Field[] df = c1.getDeclaredFields();    <span class="comment">//可以找到全部的属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : df) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        <span class="comment">//获得类的方法</span></span><br><span class="line">        Method[] m1 = c1.getMethods();<span class="comment">//获得本类及其父类的所有public方法,如果子类改写了父类的方法,那么只获得子类改写的.</span></span><br><span class="line">        Method[] dm = c1.getDeclaredMethods();<span class="comment">//获得本类的所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : m1) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method method : dm) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得指定方法</span></span><br><span class="line">        Method M1 = c1.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        System.out.println(M1);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        Class b1 = b.getClass();</span><br><span class="line">        Method[] BM1 = b1.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : BM1) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        <span class="comment">//获得指定的构造器</span></span><br><span class="line">        Constructor[] con1 = b1.getConstructors();  <span class="comment">//获得public的构造方法,编译器添加的空构造方法不在其范围内</span></span><br><span class="line">        Constructor[] dcon1 = b1.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : con1) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : dcon1) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        getFiled(),</span></span><br><span class="line"><span class="comment">        getDeclaredField(),</span></span><br><span class="line"><span class="comment">        getMethods(),</span></span><br><span class="line"><span class="comment">        getDeclaredMethod(),</span></span><br><span class="line"><span class="comment">        getConstructor(),</span></span><br><span class="line"><span class="comment">        getDeclaredConstructor(),</span></span><br><span class="line"><span class="comment">        获得指定的属性,方法,构造器,有无Declared的差别同上面的一致</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>在实际的操作中,取得类的信息的操作代码,并不会经常开发。</li>
<li>一定要熟悉java.lang.reflect包的作用，反射机制。</li>
<li>如何取得属性、方法、构造器的名称、修饰符等。</li>
</ul>
<h4 id="有了Class对象，能做什么？"><a href="#有了Class对象，能做什么？" class="headerlink" title="有了Class对象，能做什么？"></a>有了Class对象，能做什么？</h4><ul>
<li>创建类的对象：调用Class对象的newInstance()方法<ul>
<li>类必须有一个无参数的构造器</li>
<li>类的构造器的访问权限需要足够</li>
</ul>
</li>
<li><strong>思考</strong>难道没有无参的构造器就不能创建对象了吗？只有在操作的时候明确的调用类中的构造器，并将参数传递进去后，就可以实例化操作。</li>
<li>步骤如下：<ol>
<li>通过Class类的GetDeclaredConstructor(Class … parameterType)取得本类的指定形参类型的构造器</li>
<li>向构造器的形参中传递一个对象数组进去,里面包含了构造器中所需要的各个参数。</li>
<li>通过Constructor实例化对象。</li>
</ol>
</li>
</ul>
<h4 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h4><h5 id="调用指定的方法"><a href="#调用指定的方法" class="headerlink" title="调用指定的方法"></a>调用指定的方法</h5><p>通过反射，调用类中的方法，通过Method类完成。</p>
<ul>
<li><p>通过Class类的getMethod（String name，Class … parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</p>
</li>
<li><p>之后用Object invoke（Object obj，Object[] args) 进行调用,并向方法中传递要设置的obj对象的参数信息。</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201229234031916.png" alt="image-20201229234031916"></p>
</li>
<li><p>**Object invoke（Object obj，Object[] args) **</p>
<ul>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null。</li>
<li>若原方法为静态方法，此时形参Object obj可为null</li>
<li>若原方法形参列表位空，则Object[] args可谓null</li>
<li>若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法。</li>
</ul>
</li>
<li><p><strong>setAccessible</strong></p>
<ul>
<li>Method和Field、Constructor对象都有setAccessible()方法。</li>
<li>setAccessible()作用是启动和禁止访问安全检查的开关。</li>
<li>参数值为true则是表明反射对象在使用时应该取消Java语言访问检查。<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li>
<li>使得原本无法访问的私有成员也可以被访问</li>
<li>参数值为false则表示反射对象在使用时应强制进行Java语言访问检查。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射, 动态的创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">//获得Class对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.lhf_siven.Reflection.User&quot;</span>);</span><br><span class="line">        <span class="comment">//构造一个对象</span></span><br><span class="line">        User user  = (User)c1.newInstance();    <span class="comment">//本质上是调用了类的无参构造器</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过构造器创建对象</span></span><br><span class="line">        Constructor con1 = c1.getConstructor(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        User user1 = (User)con1.newInstance(<span class="string">&quot;name&quot;</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用普通方法</span></span><br><span class="line">        User user2 = (User)c1.newInstance();</span><br><span class="line">        <span class="comment">//通过反射获取一个方法</span></span><br><span class="line">        Method setName = c1.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//invoke: 激活 (Object,Object...args)</span></span><br><span class="line">        setName.invoke(user2,<span class="string">&quot;lhf&quot;</span>);</span><br><span class="line">        System.out.println(user2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射操作属性</span></span><br><span class="line">        User user3 = (User)c1.newInstance();</span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//设置反射对象在使用时是否进行java语言访问控制,值为true时不检查,因此即使是被private修饰的属性也可以访问到,</span></span><br><span class="line">        <span class="comment">// 值为false的时候,则强制检查.</span></span><br><span class="line">        <span class="comment">//不能直接操作私有属性,我们需要提前关闭程序的安全检测</span></span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(user3,<span class="string">&quot;siven&quot;</span>);</span><br><span class="line">        System.out.println(user3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="性能对比分析"><a href="#性能对比分析" class="headerlink" title="性能对比分析"></a>性能对比分析</h4><p>普通方式调用、反射方式调用、关闭检测的反射方式调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分析性能问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test07</span> </span>&#123;</span><br><span class="line">    <span class="comment">//普通方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通方式执行10亿次:&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user);</span><br><span class="line">        &#125;</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射方式执行10亿次:&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射方式调用,关闭检测</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        getName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射方式关闭检测执行10亿次:&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">        test03();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    普通方式执行10亿次:3ms</span></span><br><span class="line"><span class="comment">    反射方式执行10亿次:2475ms</span></span><br><span class="line"><span class="comment">    反射方式关闭检测执行10亿次:1795ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>经测试用反射来调用方法是要比直接用类来调用慢很多，而关闭检测则会让效率相对提高，但同样的会降低安全性，实际运用中在效率和安全上要做一个取舍。</strong></p>
<h4 id="反射操作泛型"><a href="#反射操作泛型" class="headerlink" title="反射操作泛型"></a>反射操作泛型</h4><ul>
<li>Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除。</li>
<li>为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的但是又和原始类型齐名的类型。</li>
<li>ParameterizedType：表示一种参数化类型，比如Collection<String></String></li>
<li>GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型。</li>
<li>TypeVariable：是各种类型变量的公共父接口。</li>
<li>WildcardType：代表一种通配符类型表达式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射获取泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,User&gt; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test02&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        Method method = Test08.class.getDeclaredMethod(&quot;test01&quot;, Map.class, List.class);</span><br><span class="line"></span><br><span class="line">        Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;#&quot;</span>+genericParameterType);</span><br><span class="line">            <span class="keyword">if</span>(genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;##&quot;</span>+actualTypeArgument);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method method2 = Test08.class.getDeclaredMethod(&quot;test02&quot;, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Type genericReturnType = method2.getGenericReturnType();</span><br><span class="line">        System.out.println(genericParameterTypes);</span><br><span class="line">        <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;!!&quot;</span>+actualTypeArgument);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #java.util.Map&lt;java.lang.String, com.lhf_siven.Reflection.User&gt;</span></span><br><span class="line"><span class="comment">    ##class java.lang.String</span></span><br><span class="line"><span class="comment">    ##class com.lhf_siven.Reflection.User</span></span><br><span class="line"><span class="comment">    #java.util.List&lt;com.lhf_siven.Reflection.User&gt;</span></span><br><span class="line"><span class="comment">    ##class com.lhf_siven.Reflection.User</span></span><br><span class="line"><span class="comment">    !java.util.Map&lt;java.lang.String, com.lhf_siven.Reflection.User&gt;</span></span><br><span class="line"><span class="comment">    !!class java.lang.String</span></span><br><span class="line"><span class="comment">    !!class com.lhf_siven.Reflection.User</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h4><ul>
<li>getAnnotations</li>
<li>getAnnotation</li>
</ul>
<h5 id="练习-ORM"><a href="#练习-ORM" class="headerlink" title="练习:ORM"></a>练习:ORM</h5><ul>
<li><p>了解什么是ORM?</p>
<ul>
<li><p>Object relationship Mapping –&gt; 对象关系映射</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201231213929030.png" alt="image-20201231213929030"></p>
</li>
<li><p>类和表结构对应</p>
</li>
<li><p>属性和字段对应</p>
</li>
<li><p>对象和记录对应</p>
</li>
</ul>
</li>
<li><p>要求：利用注解和反射完成类和表结构的映射关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lhf_siven.demo.Outer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习反射操作注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class stu = Class.forName(<span class="string">&quot;com.lhf_siven.Reflection.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//通过反射获得类的注解</span></span><br><span class="line">        Annotation[] annotations = stu.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得注解的value</span></span><br><span class="line">        TableSiven annotation = (TableSiven)stu.getAnnotation(TableSiven.class);</span><br><span class="line">        System.out.println(annotation.value());</span><br><span class="line">        <span class="comment">//获得类字段的注解</span></span><br><span class="line">        Field name = stu.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        FieldSiven annotation1 = (FieldSiven)name.getAnnotation(FieldSiven.class);</span><br><span class="line">        System.out.println(annotation1.columnName()+<span class="string">&quot; &quot;</span>+annotation1.type()+<span class="string">&quot; &quot;</span>+annotation1.length());</span><br><span class="line">        Field id = stu.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        FieldSiven annotation2 = (FieldSiven)id.getAnnotation(FieldSiven.class);</span><br><span class="line">        System.out.println(annotation2.columnName()+<span class="string">&quot; &quot;</span>+annotation2.type()+<span class="string">&quot; &quot;</span>+annotation2.length());</span><br><span class="line">        Field age = stu.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        FieldSiven annotation3 = (FieldSiven)age.getAnnotation(FieldSiven.class);</span><br><span class="line">        System.out.println(annotation3.columnName()+<span class="string">&quot; &quot;</span>+annotation3.type()+<span class="string">&quot; &quot;</span>+annotation3.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@TableSiven(&quot;db_student&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="meta">@FieldSiven(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 12)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@FieldSiven(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@FieldSiven(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 3)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> TableSiven&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//属性的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FieldSiven&#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @com.lhf_siven.Reflection.TableSiven(value=db_student)</span></span><br><span class="line"><span class="comment">    db_student</span></span><br><span class="line"><span class="comment">    db_name varchar 3</span></span><br><span class="line"><span class="comment">    db_id int 12</span></span><br><span class="line"><span class="comment">    db_age int 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h4 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h4><ul>
<li><p>JVM的位置</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/20200325111818566.png" alt="在这里插入图片描述"></p>
</li>
<li></li>
</ul>
<h3 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h3><h3 id="字节码与类的加载"><a href="#字节码与类的加载" class="headerlink" title="字节码与类的加载"></a>字节码与类的加载</h3><h3 id="性能监控与调优"><a href="#性能监控与调优" class="headerlink" title="性能监控与调优"></a>性能监控与调优</h3><h3 id="大厂面试"><a href="#大厂面试" class="headerlink" title="大厂面试"></a>大厂面试</h3><h4 id="毕业设计"><a href="#毕业设计" class="headerlink" title="毕业设计"></a>毕业设计</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208101126683.png" alt="image-20201208101126683"></p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208102041319.png" alt="image-20201208102041319"></p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208102205677.png" alt="image-20201208102205677"></p>
<p>近三年的文献不能少于40%,尽量多</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208102444709.png" alt="image-20201208102444709"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="prev" title="操作系统">
      <i class="fa fa-chevron-left"></i> 操作系统
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/22/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="next" title="常用快捷键">
      常用快捷键 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-number">1.</span> <span class="nav-text">小技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">2.</span> <span class="nav-text">Java内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">包机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaDoc"><span class="nav-number">7.</span> <span class="nav-text">JavaDoc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">8.</span> <span class="nav-text">Java流程控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scanner%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.</span> <span class="nav-text">Scanner对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-number">10.</span> <span class="nav-text">顺序结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="nav-number">11.</span> <span class="nav-text">选择结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">12.</span> <span class="nav-text">循环结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#break-amp-continue"><span class="nav-number">13.</span> <span class="nav-text">break&amp;continue</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">Java方法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">1.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82-%E4%B8%8D%E5%AE%9A%E9%A1%B9-%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">可变参(不定项)数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Arrays-%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">Arrays 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="nav-number">5.</span> <span class="nav-text">内存分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">6.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="nav-number">7.</span> <span class="nav-text">稀疏数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">什么是面向对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">类和对象的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">创建与初始化对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">5.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">6.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super"><span class="nav-number">7.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-number">8.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#public-gt-protected-gt-default-gt-private"><span class="nav-number">9.</span> <span class="nav-text">public &gt; protected &gt; (default) &gt; private</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">10.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof"><span class="nav-number">11.</span> <span class="nav-text">instanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static"><span class="nav-number">12.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">13.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">14.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3VS%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">15.</span> <span class="nav-text">接口VS抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%91%E7%BA%A6%E8%AE%BE%E8%AE%A1"><span class="nav-number">16.</span> <span class="nav-text">契约设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">17.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6-Exception"><span class="nav-number">18.</span> <span class="nav-text">异常机制(Exception)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number"></span> <span class="nav-text">异常体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Error"><span class="nav-number">1.</span> <span class="nav-text">Error</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exception"><span class="nav-number">2.</span> <span class="nav-text">Exception</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">异常处理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">4.</span> <span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">实际应用中的经验总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number"></span> <span class="nav-text">常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">Object 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">Math类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Random%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">Random类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">File类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">Date类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text">String 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">StringBuffer类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuilder%E7%B1%BB"><span class="nav-number">9.</span> <span class="nav-text">StringBuilder类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-number"></span> <span class="nav-text">集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">总览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList"><span class="nav-number">2.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList"><span class="nav-number">3.</span> <span class="nav-text">LinkedList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet"><span class="nav-number">4.</span> <span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet"><span class="nav-number">5.</span> <span class="nav-text">TreeSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E9%87%8D%E7%82%B9"><span class="nav-number">6.</span> <span class="nav-text">HashMap(重点)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-number"></span> <span class="nav-text">IO流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">1.</span> <span class="nav-text">线程创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread"><span class="nav-number">2.</span> <span class="nav-text">Thread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87"><span class="nav-number">3.</span> <span class="nav-text">案例：下载图片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.</span> <span class="nav-text">实现Runnable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E8%AF%86%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">初识并发问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.</span> <span class="nav-text">实现Callable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">静态代理模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">lambda表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">线程方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2"><span class="nav-number">10.</span> <span class="nav-text">线程停止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0%EF%BC%88Sleep%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">线程休眠（Sleep）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%EF%BC%88Yield%EF%BC%89"><span class="nav-number">12.</span> <span class="nav-text">线程礼让（Yield）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C%EF%BC%88Join%EF%BC%89"><span class="nav-number">13.</span> <span class="nav-text">线程强制执行（Join）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B"><span class="nav-number">14.</span> <span class="nav-text">线程状态观测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">15.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4-daemon-%E7%BA%BF%E7%A8%8B"><span class="nav-number">16.</span> <span class="nav-text">守护(daemon)线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">17.</span> <span class="nav-text">线程同步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">网络编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GUI"><span class="nav-number"></span> <span class="nav-text">GUI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3-Annotation"><span class="nav-number"></span> <span class="nav-text">注解(Annotation)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">内置注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">元注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">自定义注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%EF%BC%88Reflection%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">反射（Reflection）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81VS%E5%8A%A8%E6%80%81%E7%94%A8%E8%AF%AD%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">静态VS动态用语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-Reflection"><span class="nav-number">2.</span> <span class="nav-text">Java Reflection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">3.</span> <span class="nav-text">Java反射机制提供的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">Java反射的优点和缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%BB%E8%A6%81API"><span class="nav-number">5.</span> <span class="nav-text">反射相关的主要API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">Class类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%9C%89Class%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.1.</span> <span class="nav-text">哪些类型可以有Class对象?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="nav-number">7.</span> <span class="nav-text">类加载内存分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="nav-number">7.1.</span> <span class="nav-text">Java内存分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">类的加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">9.</span> <span class="nav-text">类的加载与ClassLoader的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">什么时候会发生类初始化？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">11.</span> <span class="nav-text">类加载器的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="nav-number">12.</span> <span class="nav-text">获取运行时类的完整结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%80%A6%E2%80%A6"><span class="nav-number">12.0.1.</span> <span class="nav-text">……</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">12.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E4%BA%86Class%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">有了Class对象，能做什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95"><span class="nav-number">14.</span> <span class="nav-text">动态创建对象执行方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">14.1.</span> <span class="nav-text">调用指定的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="nav-number">15.</span> <span class="nav-text">性能对比分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%9B%E5%9E%8B"><span class="nav-number">16.</span> <span class="nav-text">反射操作泛型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%A8%E8%A7%A3"><span class="nav-number">17.</span> <span class="nav-text">反射操作注解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-ORM"><span class="nav-number">17.1.</span> <span class="nav-text">练习:ORM</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">18.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number"></span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E6%8E%A2%E7%A9%B6"><span class="nav-number">1.</span> <span class="nav-text">JVM探究</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number"></span> <span class="nav-text">内存与垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number"></span> <span class="nav-text">字节码与类的加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98"><span class="nav-number"></span> <span class="nav-text">性能监控与调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95"><span class="nav-number"></span> <span class="nav-text">大厂面试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">毕业设计</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lhf_siven</p>
  <div class="site-description" itemprop="description">努力变成更好的自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/siven1987" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;siven1987" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lhf_siven@qq.com" title="E-Mail → mailto:lhf_siven@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lhf_siven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>-->
