<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="努力变成更好的自己">
<meta property="og:type" content="website">
<meta property="og:title" content="lhf_siven">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="lhf_siven">
<meta property="og:description" content="努力变成更好的自己">
<meta property="og:locale">
<meta property="article:author" content="lhf_siven">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>lhf_siven</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">lhf_siven</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/" class="post-title-link" itemprop="url">字符串题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-24 10:54:09" itemprop="dateCreated datePublished" datetime="2020-08-24T10:54:09+08:00">2020-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:24:51" itemprop="dateModified" datetime="2020-09-13T09:24:51+08:00">2020-09-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h4><p><strong>题目</strong></p>
<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<blockquote>
<p>例如:</p>
<p>输入：“abab”        输入：”aba“</p>
<p>输出： “True”        输出：”False“</p>
</blockquote>
<p>这里首先给个结论:</p>
<p>假设字符串为s,若(s+s),在(0,-1)(即不包含首尾字符)上还能找到一个s则说明s可以有重复的子字符串组成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*普通的枚举法</span></span><br><span class="line"><span class="comment">       for(int x=1;x*2&lt;=s.length();x++)&#123;</span></span><br><span class="line"><span class="comment">           if(s.length()%x==0)&#123;</span></span><br><span class="line"><span class="comment">               bool b = true;</span></span><br><span class="line"><span class="comment">               for(int y=x;y&lt;s.length();y++)&#123;</span></span><br><span class="line"><span class="comment">                   if(s[y]!=s[y-x])&#123;</span></span><br><span class="line"><span class="comment">                       b = false;</span></span><br><span class="line"><span class="comment">                       break;</span></span><br><span class="line"><span class="comment">                   &#125;</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">               if(b) return true;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">       &#125;*/</span></span><br><span class="line">       <span class="comment">//(s+s)(0,-1)has_s?</span></span><br><span class="line">       <span class="built_in">string</span> str = s.substr(<span class="number">1</span>)+s.substr(<span class="number">0</span>,s.length()<span class="number">-1</span>);</span><br><span class="line">       <span class="keyword">return</span> str.find(s)!=<span class="number">-1</span>;</span><br><span class="line">       <span class="comment">//在一个字符串里找一个子字符串除了用已有的库函数之外,也可以用KMP算法实现,但是太难了</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>证明:</p>
<p>充分性:</p>
<p>我们要证明当s能够由重复的子字符串组成,则(s+s)(1,-1)中还能找到一个s.</p>
<p>我们假设s的子字符串为p,那么s必然由n个以上的p组成.(n&gt;=2)</p>
<p>则s+s由2n个p以上组成,当我们掐头去尾之后,就是破坏了首尾的两个p</p>
<p>但是s+s中还是由连续的2n-2个p ,即(n+n-2)个连续的p,因为s由n个p组成且n&gt;=2,</p>
<p>所以(s+s)在(1,-1)上肯定还有至少一个s的存在。</p>
<p>必要性：</p>
<p>接下来我们要证明，当（s+s）（0，-1）上还能找到一个s时，s由重复的字符串组成</p>
<p>假设str=（s+s）</p>
<p>那么[0,n-1]和[n,2n-1]分别是两个s.</p>
<p>现在不包含首尾字符也能找到一个s,假设该s的起始下标为i,那么对应的范围应该是[i,i+n-1]</p>
<p>显然它的首尾分别处于两个s的范围内。我们以n-1为界可以得到以下两个式子</p>
<p>str[0,n-i-1] = str[i,n-1]</p>
<p>str[n-i-1,n-1]=str[n,i+n-1] = str[0,i-1]</p>
<p>由上面两个式子进一步可以得到</p>
<p>s[0,n-i-1] = str[i,n-1] ,假设他们为a</p>
<p>str[n-i-1,n-1] = str[0,i-1] ，假设他们为b</p>
<p>根据下标顺序我们会发现ab=ba=s</p>
<p>也就是说s是一个可翻转的字符串。当我们将前i个字符即，str[0,i-1]放到str[i,n-1]之后字符串依旧不变，这意味着str[0,i-1] = str[i,2i-1]。</p>
<p>同时，由于翻转之后还是同一个字符串，意味着我们还能够继续将前i字符串翻转到后面，又能得到str[0,i-1] = str[i,2i-1] = str[2i,3i-1].</p>
<p>不断反转我们 就能得到结论str[j]=str[j+i],也就是说存在一个长度为i的重复字符串可以组成s。</p>
<p>所以综上，我们证明了s由重复子字符串组成的充要条件是，（s+s）在（0，-1）（即掐头去尾）上能够找到一个s。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/23/%E5%B0%8F%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/23/%E5%B0%8F%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">小技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-23 09:11:59" itemprop="dateCreated datePublished" datetime="2020-08-23T09:11:59+08:00">2020-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:24:34" itemprop="dateModified" datetime="2020-09-13T09:24:34+08:00">2020-09-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="这个博文用来记录我在刷题过程中经常用到的一些操作"><a href="#这个博文用来记录我在刷题过程中经常用到的一些操作" class="headerlink" title="这个博文用来记录我在刷题过程中经常用到的一些操作"></a>这个博文用来记录我在刷题过程中经常用到的一些操作</h3><hr>
<h4 id="int与string互转"><a href="#int与string互转" class="headerlink" title="int与string互转"></a>int与string互转</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用&lt;sstream&gt;头文件里的<span class="built_in">stringstream</span>来实现转换,十分方便.</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toint</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    ss&gt;&gt;res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">tostring</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;<span class="built_in">string</span> s;</span><br><span class="line">    ss&lt;&lt;x;</span><br><span class="line">    ss&gt;&gt;s;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="求二进制数中1的个数"><a href="#求二进制数中1的个数" class="headerlink" title="求二进制数中1的个数"></a>求二进制数中1的个数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一个二进制数的末尾要么是<span class="number">01</span>要么是<span class="number">1.</span>.<span class="number">.0</span>这种类型,他们减<span class="number">1</span>之后就会变成<span class="number">00</span>和<span class="number">01.</span>.<span class="number">.1</span>,对应的相互&amp;之后会变成<span class="number">00</span>和<span class="number">00.</span>.<span class="number">.0</span>,即达到了消除最后出现的<span class="number">1</span>的效果.</span><br><span class="line">也就是说执行一次 n&amp;=n<span class="number">-1</span>,n对应的二进制数中的<span class="number">1</span>的个数就减<span class="number">1</span>,假设n执行k次该操作变成了<span class="number">0</span>,那么就说明n中有k个<span class="number">1.</span></span><br><span class="line"><span class="keyword">int</span> BON(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">        x &amp;= x<span class="number">-1</span>;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="给定范围-m-n-的按位与结果"><a href="#给定范围-m-n-的按位与结果" class="headerlink" title="给定范围[m,n]的按位与结果"></a>给定范围[m,n]的按位与结果</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; m) &#123;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析见leetcode201题,文字描述就是[m,n]范围内所有数的按位&amp;的结果是m和n的公共前缀+余位补0.</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/22/%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/22/%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-22 13:21:34" itemprop="dateCreated datePublished" datetime="2020-08-22T13:21:34+08:00">2020-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-18 00:14:48" itemprop="dateModified" datetime="2020-09-18T00:14:48+08:00">2020-09-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="排序算法-Sort"><a href="#排序算法-Sort" class="headerlink" title="排序算法/Sort"></a>排序算法/Sort</h3><p>排序算法可以说是我们最常使用的算法了,里头的内容很多,也很有用。这篇博文就用来记录常用的排序算法。</p>
<h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><hr>
<p><strong>基本的排序算法</strong> 【简单直接助你迅速写出没有bug的代码】</p>
<ul>
<li>冒泡排序/Bubble Sort</li>
<li>插入排序/Insertion Sort</li>
<li>选择排序/Selection Sort</li>
</ul>
<p><strong>常考的排序算法</strong> 【解决绝大部分涉及排序问题的关键】</p>
<ul>
<li>归并排序/Merge Sort</li>
<li>快速排序/Quick Sort</li>
<li>拓扑排序/Topological Sort</li>
</ul>
<p><strong>其他排序算法</strong> 【掌握好它们的解题思想能开阔解题思路】</p>
<ul>
<li>堆排序/Heap Sort</li>
<li>桶排序/Bucket Sort</li>
</ul>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><hr>
<p><strong>算法思想</strong></p>
<ul>
<li>每一轮，从杂乱无章的数组头部开始，每<strong>两个元素比较大小</strong>进行交换；</li>
<li>直到这一轮当中最大或最小的元素被放置在数组的尾部</li>
<li>然后不断重复这个过程，直到所有元素都排好位置</li>
<li>要注意的是，排序过程中，可能在某一轮序列就已经有序，所以我们维护一个bool值Swap用来记录本次迭代是否有进行两个元素位置的交换，如果没有，则排序终止，如果有则继续。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v,<span class="keyword">int</span> x ,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//两个数的交换有很多种方法，常用的是用一个temp暂存其中一个值</span></span><br><span class="line">    <span class="comment">//这里选择用异或a^b=c,c^a=b,c^b=a的特性来交换。</span></span><br><span class="line">    v[x] = v[x]^v[y];</span><br><span class="line">    v[y] = v[x]^v[y];</span><br><span class="line">    v[x] = v[x]^v[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bubble</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> Swap = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//冒泡</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;len<span class="number">-1</span>;x++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[x]&gt;v[x+<span class="number">1</span>])&#123;</span><br><span class="line">            swap(v,x,x+<span class="number">1</span>);</span><br><span class="line">            Swap = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Swap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">    <span class="comment">//一开始待排序数组长度为v.size(),随后不断-1，直到待排序的数组长度为1，跳出排序。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=v.size();x&gt;<span class="number">1</span>&amp;&amp;Bubble(v,x);x--); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p><strong>空间复杂度：O（1）</strong></p>
<p>假设数组的元素个数是n，整个排序的过程中，直接在给定的数组里进行元素的亮亮交换。</p>
<p><strong>时间复杂度：O（n^2)</strong></p>
<ul>
<li><p>给定数组按照顺序已经排好</p>
<p>只需要进行n-1次的比较,两两交换次数为0,时间复杂度是O(n),这是最好的情况</p>
</li>
<li><p>给定数组按逆序排列</p>
<p>需要进行n(n-1)/2 （即1+…+n-1）次比较和两两交换，时间复杂度是0（n^2),这是最坏的情况。</p>
</li>
<li><p>给定的数组杂乱无章</p>
<p>在这种情况下，平均时间复杂度是O(n^2)</p>
</li>
<li><p>由此可见冒泡排序的时间复杂度是O（n^2）</p>
</li>
</ul>
<p><strong>冒泡排序是一种稳定的排序算法，所谓稳定，也就是说对于数组里两个相等的数，经过排列后，这两个数的相对位置保持不变。</strong></p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><hr>
<p><strong>遇冒泡排序对比</strong></p>
<ul>
<li>在冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的；</li>
<li>在插入排序中，经过每一轮的排序处理后，数组后端的数是排好序的；</li>
</ul>
<p><strong>算法思想</strong></p>
<p>不断地将尚未排好序的数插入到已经排好序的部分。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><hr>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11K4y1b7bC?from=search&amp;seid=1328949494534586893">https://www.bilibili.com/video/BV11K4y1b7bC?from=search&amp;seid=1328949494534586893</a></p>
<p>一个序列怎样才算是排好序的呢?</p>
<p>我们认为,序列中每一个数都满足,它左边的数比它小,它右边的数比它大的时候,这个序列是有序的。</p>
<p>而上面这一思想就体现了快排的思想。</p>
<p>对于一个数组，我们随机选一个数，让它左边的数都比它小，让它右边的数都比它大，然后左右两个子序列递归这个过程，就可以实现排序的过程。</p>
<p>Lomuto实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    v[x] = v[x]^v[y];</span><br><span class="line">    v[y] = v[x]^v[y];</span><br><span class="line">    v[x] = v[x]^v[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里pivot设置成了最左边的元素,实际上可以任意选择.</span></span><br><span class="line"><span class="comment">          Partition将序列分成四个部分:</span></span><br><span class="line"><span class="comment">          pivot-&gt;比pivot小的序列-&gt;比pivot大的序列-&gt;待处理的序列.</span></span><br><span class="line"><span class="comment">          用指针j,i分别指向比pivot小的序列的末尾和待处理序列的第一个元素.</span></span><br><span class="line"><span class="comment">          当v[i]比pivot大时,那么只需要i++,该元素就会被加入到大于pivot的序列中,</span></span><br><span class="line"><span class="comment">          当v[i]小于或等于pivot的时候,只需要将第j+1的元素与i调换,然后j++,那么该元素就会被加入到小于pivot的序列当中.</span></span><br><span class="line"><span class="comment">          当待处理序列为空,即i&gt;right的时候,则说明所有元素都以经被处理成比pivot小和比pivot大的两部分,</span></span><br><span class="line"><span class="comment">          且因为j始终指向比pivot小的序列的末尾,那么只需要将pivot对应的元素与j对应的元素调换,即可满足</span></span><br><span class="line"><span class="comment">          pivot左边的元素都比它小,右边的元素都比它大.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> pivot = left,j = pivot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pivot+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;v[pivot]) &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;j++;<span class="keyword">if</span>(j != i) swap(j,i,v);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pivot != j) swap(pivot,j,v);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意是&gt;=,因为有可能pivot是最大的,或者最小的,那么m+1,m-1就有可能比right大,比left小.</span></span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//Partition 每次确定一个元素的位置,当比它小的都在它的左边,比它大的都在它的右边的时候,那它的位置就是最终有序时候的位置.</span></span><br><span class="line">    <span class="keyword">int</span> m = Partition(left,right,v);</span><br><span class="line">    <span class="comment">//对左右两边子序列进行递归调用QuickSort;</span></span><br><span class="line">    QuickSort(left,m<span class="number">-1</span>,v);</span><br><span class="line">    QuickSort(m+<span class="number">1</span>,right,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/18/c-%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/c-%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="post-title-link" itemprop="url">c++面试准备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-18 22:18:52" itemprop="dateCreated datePublished" datetime="2020-08-18T22:18:52+08:00">2020-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-14 17:27:18" itemprop="dateModified" datetime="2020-10-14T17:27:18+08:00">2020-10-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="这个博文用来记录我准备c-面试过程中-学到的知识点"><a href="#这个博文用来记录我准备c-面试过程中-学到的知识点" class="headerlink" title="这个博文用来记录我准备c++面试过程中,学到的知识点."></a>这个博文用来记录我准备c++面试过程中,学到的知识点.</h3><hr>
<h4 id="‘-0’"><a href="#‘-0’" class="headerlink" title="‘\0’"></a>‘\0’</h4><p>在’\0’的ascii码为0,如果可以转化成数字,那么可以把他当成0来用,经测验’\0’是可以当成false来用的.</p>
<h4 id="strcpy-char-dest-const-char-src"><a href="#strcpy-char-dest-const-char-src" class="headerlink" title="strcpy(char* dest, const char *src)"></a>strcpy(char* dest, const char *src)</h4><blockquote>
<p>头文件：#include &lt;string.h&gt;</p>
<p>原型声明：char <em>strcpy(char</em> *dest, const char *src);</p>
<p>strcpy，即string copy（字符串复制）的缩写。<br>strcpy是一种C语言的标准库函数，strcpy把含有’\0’结束符的字符串复制到另一个地址空间，返回值的类型为char*。</p>
</blockquote>
<p><strong>实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">( <span class="keyword">char</span> *strDest, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc )</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> assert( (strDest != <span class="literal">NULL</span>) &amp;&amp; (strSrc != <span class="literal">NULL</span>) ); </span><br><span class="line"> <span class="keyword">char</span> *address = strDest;  </span><br><span class="line"> <span class="keyword">while</span>( (*strDest++ = * strSrc++) != ‘\<span class="number">0</span>’ );  </span><br><span class="line"> <span class="keyword">return</span> address; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>对与这个函数我们要注意以下几点</p>
<ul>
<li>‘\0’同样会被复制</li>
<li>strcpy是以’\0’为终止符的,如果没有’\0’将导致strcpy一直复制下去，直到遇到’\0’为止。所以拷贝的长度是不定的。如果一直没有遇到’\0’导致越界访问非法内存，程序就崩了。</li>
</ul>
<p>举例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">10</span>]; </span><br><span class="line"> <span class="keyword">char</span>* str1 = <span class="string">&quot;01234567891&quot;</span>; </span><br><span class="line"> <span class="built_in">strcpy</span>( <span class="built_in">string</span>, str1 ); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段代码可以编译运行,但他却隐含了一个错误,那就是数组越界,</span></span><br><span class="line"><span class="comment">系统分配给string的只有10个字节,但是strcpy会将12个字节(包括&#x27;/0&#x27;)复制到string的首地址处,</span></span><br><span class="line"><span class="comment">这将导致有两个字节的内存会被覆盖掉,这是一个潜在的隐患,因为我们这两个字节可能被分配给了其他地方.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="strlen（char-s）"><a href="#strlen（char-s）" class="headerlink" title="strlen（char *s）"></a>strlen（char<code> </code>*s）</h4><blockquote>
<p>strlen所作的是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符’\0’为止，然后返回计数器值(长度不包含’\0’)。</p>
</blockquote>
<p>注意以下几点</p>
<ul>
<li>strlen的返回值的长度是不包括’\0’的,且遇到’\0’就会返回,例如</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>] =&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出的值分别为2和5;</span></span><br></pre></td></tr></table></figure>



<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><blockquote>
<p>头文件：&lt;stdlib.h&gt;</p>
<p>原型声明：void *malloc(unsigned int size)；size为请求分配的内存大小，单位为字节。</p>
<p>作用： 分配所需的内存空间，并返回一个指向它的指针，如果请求失败则返回NULL。要注意的是</p>
</blockquote>
<p>注意以下几点：</p>
<ul>
<li>形参size_t必须是&gt;=0的整数</li>
<li>malloc返回的是void* （无类型指针）所以我们使用的时候要将他强转成为我们想要的类型。 </li>
<li>如果内存紧张，可能导致分配失败，此时会返回NULL，所以要对分配结果进行检查。</li>
<li>使用free释放malloc申请的内存后,要将对应指针置为NULL,否则可能会出现野指针的问题。</li>
<li>malloc同new一样，分配的内存需要自己手动释放，不然会导致内存泄漏，malloc（）分配的内存由free（）释放。</li>
<li>同new的区别，malloc（）需要我们自己计算字节数，并且在返回的时候强转成实际指定类型的指针；而new返回指定类型的指针，并且可以自动计算所需要的大小</li>
</ul>
<h4 id="传值和传址"><a href="#传值和传址" class="headerlink" title="传值和传址"></a>传值和传址</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">( <span class="keyword">char</span> *p )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>( <span class="number">100</span> ); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">( <span class="keyword">void</span> )</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line"> GetMemory( str );  </span><br><span class="line"> <span class="built_in">strcpy</span>( str, <span class="string">&quot;hello world&quot;</span> ); </span><br><span class="line"> <span class="built_in">printf</span>( str ); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>传址和传值是一个我们经常犯错的地方.例如上面的char *p实际上是一个char指针类型的形参,我们可以通过p来对齐指向的内存的数据做处理,但是如果我们改变p指向的内存,则并不会影响实参所指向的内存,因为这是传值,只有将char *p 改成char *&amp;p时,才是传址,我们才能够对实参产生影响.</p>
<p>上面这段代码就犯了将传值当传址用的错误，GetMemory只是声明了一个指针p做了一个复制，与str指向了同一个地址，但是之后p指向了malloc开辟的新内存，并不会对str有任何的影响，所以str依旧是NULL，会导致程序崩溃，此外上面代码也没有free掉malloc开辟的内存，所以还造成了内存泄露。</p>
<h4 id="char"><a href="#char" class="headerlink" title="char[]"></a>char[]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[5] &#x3D; &quot;hello&quot;;</span><br><span class="line">&#x2F;&#x2F;上面这句话无法通过编译,因为如果是这样初始话的话必须把&#39;\0&#39;的内存也考虑进来,即a的大小应该是6个字节而非5个.</span><br></pre></td></tr></table></figure>



<h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><blockquote>
<p>定义: 野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p>
</blockquote>
<p><strong>成因</strong></p>
<ul>
<li>指针变量未初始化<ul>
<li>任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</li>
</ul>
</li>
<li>指针释放后之后未置空<ul>
<li>有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。</li>
</ul>
</li>
<li>指针操作超越变量作用域<ul>
<li>不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。示例程序如下：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Func of <span class="class"><span class="keyword">class</span> <span class="title">A</span>” &lt;&lt; endl; &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class">class B &#123;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">  A *p;</span></span><br><span class="line"><span class="class">  void Test(void) &#123;</span></span><br><span class="line"><span class="class">    A a;</span></span><br><span class="line"><span class="class">    p = &amp;a; // 注意a的生命期 ，只在这个函数Test中，而不是整个class B</span></span><br><span class="line"><span class="class">  &#125;</span></span><br><span class="line"><span class="class">  void Test1() &#123;</span></span><br><span class="line"><span class="class">  p-&gt;Func(); // p 是“野指针”</span></span><br><span class="line"><span class="class">  &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//在这个程序中,p并没有初始话,所以一开始他就是野指针</span></span><br><span class="line"><span class="class">//而在Test中,尽管我们将p指向了a,但是由于a是函数内的局部变量,当Test()执行完之后,a对应的内存会被释放掉,所以说p又成了野指针.</span></span><br></pre></td></tr></table></figure>



<h4 id="bool，int，float，指针与“零值”比较"><a href="#bool，int，float，指针与“零值”比较" class="headerlink" title="bool，int，float，指针与“零值”比较"></a>bool，int，float，指针与“零值”比较</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设变量名为 var</span></span><br><span class="line"><span class="comment">BOOL型变量：if(!var)   </span></span><br><span class="line"><span class="comment">int型变量： if(0==var)   </span></span><br><span class="line"><span class="comment">float型变量：   </span></span><br><span class="line"><span class="comment">const float EPSINON = 0.00001;   </span></span><br><span class="line"><span class="comment">if ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON)   </span></span><br><span class="line"><span class="comment">指针变量：　　if(NULL==var)  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意点:</p>
<ul>
<li>0 == var, NULL == var这样的写法比var == 0, var == NULL要更优一点,虽然他们产生的效果是一样的,但是将常量放在等式的左边可以有效的规避我们不小心将”==”写成”=”的情况，如果我们用后面那种写法，当我们漏写“=”号时，编译器是无法找到错误的，因为这并不是语法上的错误，如果代码的体量比较大，那么这个问题是会蛮难找的，所以用前者写法是较优的。</li>
<li>float，double这些浮点类型的数据是存在精度上的问题的，所以不可将float变量用“==”或“！=”与数字比较，应该设法转化成“&gt;=”或“&lt;=”形式. 一般来说，我们定义某个较小的范围来作为0值,如上面的EPSILON。举例:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">1.519</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">1.518</span>;</span><br><span class="line">    <span class="keyword">float</span> c = a-b</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(a-b==<span class="number">0.001</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">1.519</span></span><br><span class="line"><span class="number">1.518</span></span><br><span class="line"><span class="number">0.00100005</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment">//可见除了通过直接赋值(精度内)我们能够确保float变量的值之外,若我们通过四则运算等对float的值做处理的话所得到的值是存在一定误差的,所以float与零值的比较,除非我们是直接将0赋值给var,否则0==var这样的操作基本上是无意义的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在&lt;float.h&gt;中,定义了FLT_EPSILON,DBL_EPSILON来作为float,double与零值比较的范围</li>
</ul>
<h4 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h4><ol>
<li><p>结构体定义的时候,变量成员的顺序会影响结构体的大小.</p>
</li>
<li><p>对齐:成员变量以什么样的方式排列,紧密排列或中间有间隔的松散类型.</p>
</li>
<li><p>编译器对于对齐方式，是可以选择的，vs默认是8字节对齐。</p>
<ul>
<li>int类型：4字节，如果编译设置的对齐方式，大于或等于4字节，那么就必须以4字节的倍数分配地址 ，且如果结构体里面有int，那么结构体的大小就是4的整数倍。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st1</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;s1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">&#125;s2;</span><br><span class="line"><span class="comment">/*先说结论：s1占8个字节，s2占12个字节</span></span><br><span class="line"><span class="comment">   结构体st1和st2包含的数据类型都是两个char和一个int，但看它们应该占6个字节，但是由于上面我们所述的规则，当对齐方式&gt;=4字节时，存在结构体对齐，st1中int地址需要是4的倍数，所以c2后面要空两个字节才到int，st1总共占八字节；st2中c1后面空三个字节，然后int占一个字节，然后由于结构体中含int，故结构体大小需要是4的整数倍，所以c2后面还是要空三个字节，st2总共占12个字节。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于double来说同样如此，当对齐方式&gt;=8个字节的时候，结构体大小就是8的整数倍。将上面的int换成double的话，s1和s2所占的内存会分别变成16和24</li>
</ul>
</li>
<li><p>所以结构体中，如果有相同类型的变量，应该放在一起，这样可以减少结构体的空间（如果是相同类型，则不会有间隔，因为前一个变量的下一个字节又是对应所占字节数的倍数，能够用来分配给与它同类型的变量，而不同数据类型由于所占字节数不同，故放在一起的话必然会导致出现闲散内存）</p>
</li>
<li><p>结构体定义，变量类型按所占内存从小到大的顺序比较合适：建议。</p>
</li>
</ol>
<p><strong>结构体大小的影响因素</strong></p>
<ul>
<li>成员变量的大小</li>
<li>对齐方式<ul>
<li>字节对齐:1,4,8,16</li>
<li>不同类型的变量的对齐</li>
</ul>
</li>
</ul>
<p><strong>字节对齐</strong></p>
<p>用#pragma pack（{1，4，8，16}）控制对齐方式</p>
<ul>
<li><p>1 个字节对齐，会紧密排列</p>
</li>
<li><p>4个字节对齐,对于short,int类型要求从它们的地址必须是2和4的倍数,且结构体的大小要求是4的倍数,而对于double这种大于4字节的就没这个要求了,紧密排列不存在内存对齐</p>
</li>
<li><p>对于8,16同样如此,占用内存小于或者等于对齐方式的,要求地址是相应占用内存的倍数,且结构体大小需要是最大的那个类型的所占内存(小于或等于对齐方式)的倍数</p>
</li>
</ul>
<p>尽管我们能够设置对齐方式,但是如果不是特定需求最好不要乱改动。</p>
<p><strong>结构体内嵌套结构体</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st1</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">&#125;s1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st1</span> <span class="title">s1</span>;</span></span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">&#125;s2;</span><br><span class="line"><span class="comment">/* (默认8字节对齐方式)</span></span><br><span class="line"><span class="comment">    s1和s2分别占12和32个字节</span></span><br><span class="line"><span class="comment">    首先s1是12个字节这个很好分析,c1和c2都要补3个字节</span></span><br><span class="line"><span class="comment">    而st2中由于嵌套了一个s1就有点奇怪了,32是怎么来的呢?</span></span><br><span class="line"><span class="comment">    我们知道s1是中含有一个int要求是地址4的倍数,所以我们需要把s1看成是一个int</span></span><br><span class="line"><span class="comment">    分配一个4的倍数的地址给他,因此c1要占4个字节,s1由于起始地址是4的倍数,那么可以老样子分配12个内存,然后a分配八个字节</span></span><br><span class="line"><span class="comment">    c2分配八个字节(因为double存在所以结构体得是8的倍数)</span></span><br><span class="line"><span class="comment">    综上,s2占32个字节.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ol>
<li>静态全局变量(或称静态外部变量)：静态全局变量只在定义变量的源文件内有效，在同一源程序的奇它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。</li>
</ol>
<h4 id="struct和class-有什么区别？"><a href="#struct和class-有什么区别？" class="headerlink" title="struct和class 有什么区别？"></a>struct和class 有什么区别？</h4><p>从语法上讲，class 和 struct 做类型定义时只有两点区别：</p>
<ol>
<li>默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理；</li>
<li>成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。 </li>
</ol>
<h4 id="如何判断一段程序是由c编译程序（编译器）还是由c-编译程序编译的？"><a href="#如何判断一段程序是由c编译程序（编译器）还是由c-编译程序编译的？" class="headerlink" title="如何判断一段程序是由c编译程序（编译器）还是由c++编译程序编译的？"></a>如何判断一段程序是由c编译程序（编译器）还是由c++编译程序编译的？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;c++&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//判断有没有相应的内置宏(预定义宏)即可,一般来说,内置宏的命名一般以&quot;__&quot;双下划线开始</span></span><br></pre></td></tr></table></figure>



<h4 id="c-函数中值的传递方式"><a href="#c-函数中值的传递方式" class="headerlink" title="c++函数中值的传递方式"></a>c++函数中值的传递方式</h4><p>c++函数的三种传递方式：值传递、指针传递和引用传递。</p>
<p><code>事实上指针传递也是值传递，尽管我们能通过传进来的指针而对其指向的数据进行操作，但是我们对传进来的指针本身做操作，并不会影响到外面的实参，所以本质上指针传递依旧是值传递。</code></p>
<h4 id="c-虚函数和多态"><a href="#c-虚函数和多态" class="headerlink" title="c++ 虚函数和多态"></a>c++ 虚函数和多态</h4><p><strong>虚函数</strong></p>
<ul>
<li><p>在类的定义中,前面由virtual关键字的成员函数就是虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">base::get</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>virtual关键字只用在类定义里的函数声明中，写函数体的时候不用</p>
</li>
<li><p>构造函数和静态成员函数不能是虚函数。 </p>
</li>
<li><p><strong>virtual关键字主要起提示作用,提示两个方面:</strong></p>
<ul>
<li>该函数可能被子类重写</li>
<li>该函数需要动态绑定,即当父类的指针或引用关联子类的对象的时候,根据该对象的实际类型来完成调用.</li>
</ul>
</li>
</ul>
<p><strong>虚函数表</strong></p>
<ul>
<li>建立时期：虚拟函数表是在编译期就建立了，各个虚拟函数在这时被组织成    -一个虚拟函数的入口地址的数组。而对象的隐藏成员—虚拟函数表指针是在运行期—也就i是构造函数被调用时进行初始化的，这是实现多态的关键。</li>
</ul>
<p><strong>多态</strong></p>
<p>C++有两种多态，称为动多态（运行期多态）和静多态（编译器多态），静多态主要是通过模板来实现，而动多态是通过虚函数来实现的。</p>
<ul>
<li><p>派生类的指针可以赋给基类指针。</p>
</li>
<li><p>通过基类指针调用基类和派生类中同名<strong>虚函数</strong>时；</p>
<ol>
<li>若该指针指向一个基类的对象，那么被调用的是基类的虚函数；</li>
<li>若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。</li>
</ol>
<p>这种机制就叫做“多态”。 </p>
</li>
<li><p>派生类的对象也可以赋给基类的引用，同样的当这个引用调用基类和派生类中同名<strong>虚函数</strong>时，由这个引用引用的对象类型决定究竟调用的是派生类的虚函数还是基类的虚函数。</p>
</li>
<li><p>多态的作用：在面向对象的程序设计中使用多态，能够增强程序的<strong>可扩充性</strong>，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。</p>
</li>
</ul>
<p><strong>子类基类转换</strong></p>
<p>子类 -&gt; 基类 (static_cast&lt;&gt;())</p>
<p>基类 -&gt; 子类 (dynamic_cast&lt;&gt;(),转换失败返回空指针)</p>
<p>类型转换是会导致指针地址变换的.</p>
<h4 id="c和c-有什么不同"><a href="#c和c-有什么不同" class="headerlink" title="c和c++有什么不同"></a>c和c++有什么不同</h4><p>从机制上：c是面向过程的；c++是面向对象的</p>
<p>从适用的方向：c适合要求代码体积小的，效率高的场合，如嵌入式；c++适合更上层的，复杂的；</p>
<p>从名称上可以看出，c++是c的超集。</p>
<p>c语言是结构化编程语言，c++是面向对象编程语言</p>
<p>c++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。</p>
<h4 id="c和c-中struct的区别"><a href="#c和c-中struct的区别" class="headerlink" title="c和c++中struct的区别"></a>c和c++中struct的区别</h4><ol>
<li>c中没有protection行为（访问权限限制），而c++有，但默认是public.</li>
<li>c中struct内部不可以定义函数，但可以有函数指针；c++中struct内部可以定义函数。</li>
</ol>
<h4 id="sizeof（）"><a href="#sizeof（）" class="headerlink" title="sizeof（）"></a>sizeof（）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id[<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)];</span><br><span class="line"><span class="comment">/*这种写法是对的,因为sizeof是编译时运算符,编译时就可以确定,可以看成是和机器有关的常量。这里用于定义数组是没问题的*/</span></span><br></pre></td></tr></table></figure>

<p>注意：sizeof是<strong>编译时运算符</strong> </p>
<h4 id="面向对象的三个基本特征"><a href="#面向对象的三个基本特征" class="headerlink" title="面向对象的三个基本特征"></a>面向对象的三个基本特征</h4><ol>
<li>继承：继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</li>
<li>多态：允许将子类类型的指针赋值给父类类型的指针，在调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</li>
<li>封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection（private，protected，public）</li>
</ol>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>对于一个频繁使用的短小函数，我们可以使用inline关键字实现，这样能够提高效率，在c中通常用宏定义来实现这一功能。</p>
<ol>
<li>内敛函数要做参数类型检查，这是内联函数跟宏相比的优势。</li>
<li>类内部函数默认内联。</li>
<li>inline是一个建议声明关键字，对于一些很长的函数即使申明了inline也没有用，而对一些比较短的频繁使用的函数，编译器可能就会自己优化成inline的。</li>
</ol>
<h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><ol>
<li>静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。</li>
<li>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己符在在何时用free或delete释放内存。动态内存的生存期由我们自己决定，使用非常灵活，但问题也最多。</li>
</ol>
<h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><p>区别：</p>
<ul>
<li>时间（生命周期）：全局变量随主程序的创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体内部存在，退出就不存在。</li>
<li>存储：全局变量存储在全局数据区中并且在程序开始运行的时候被加载，局部变量存储在栈区。</li>
<li>使用方式：全局变量通过声明后就可以在程序的各个部分使用；局部变量只能在局部使用；</li>
<li>操作系统和编译器通过内存分配的位置来知道变量是全局变量还是局部变量。</li>
</ul>
<h4 id="有了malloc-free-为什么还要new-delete"><a href="#有了malloc-free-为什么还要new-delete" class="headerlink" title="有了malloc/free 为什么还要new/delete"></a>有了malloc/free 为什么还要new/delete</h4><p>malloc/free是c++/c语言的标准库函数，而new/delete是c++的运算符。它们都可以用于申请动态内存和释放内存。但是对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，在消亡时要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把构造函数和析构函数的任务强加于malloc/free。因此c++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意：<strong>new/delete不是库函数，是操作符，malloc/free是库函数</strong></p>
<h4 id="析构函数和虚函数"><a href="#析构函数和虚函数" class="headerlink" title="析构函数和虚函数"></a>析构函数和虚函数</h4><p>析构函数是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用也没有重载，只有在类对象的生命期结束的时候，由系统自动调用，且由释放内存空间的作用。虚函数是c++多态的一种表现，使用虚函数，我们可以灵活的进行动态绑定，当然是以一定的开销为代价。</p>
<p>要注意的是析构函数可能是虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B:A(B是A的子类)</span><br><span class="line">A &amp;a = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="comment">//类似于上述情况,如果析构函数不能是虚函数那调用的是A的析构函数,但是因为B可能存在对A的扩展,这样就会有一部分内存没有被释放掉,所以一般来说当涉及到多态的时候会将基类的析构函数设置为虚函数.</span></span><br></pre></td></tr></table></figure>



<p>引用于指针的区别:</p>
<ol>
<li>引用必须被初始话,指针不必</li>
<li>引用初始话以后不能改变,指针可以改变所指的对象</li>
<li>不存在指向空指的引用,但是存在指向空指的指针。</li>
</ol>
<h4 id="java-跟-c-联系-区别"><a href="#java-跟-c-联系-区别" class="headerlink" title="java 跟 c++ 联系,区别"></a>java 跟 c++ 联系,区别</h4><ul>
<li>c++中一个类可以继承多个父类,而Java一个类只允许继承一个父类,单根继承(所有类都继承了Object类)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int*ptr)&#123;</span><br><span class="line">    return *ptr * *ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;有没有错?</span><br></pre></td></tr></table></figure>



<h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><p>为什么我们要求const修饰成员函数,该成员函数不能改变成员变量呢?</p>
<p>因为 当我们用const修饰一个对象的时候,这个对象是无法改变的,一旦它调用了成员函数,则可能会导致成员变量发生改变,这就会与const相违背,进而导致错误.所以就出现了const修饰的成员函数,这类函数不能够改变成员变量.</p>
<h4 id="unsigned-int-与-int相加"><a href="#unsigned-int-与-int相加" class="headerlink" title="unsigned int 与 int相加"></a>unsigned int 与 int相加</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">10</span>;<span class="keyword">int</span> b = <span class="number">-20</span>;</span><br><span class="line"><span class="keyword">return</span> (a+b&gt;<span class="number">0</span>)?<span class="number">1</span>:<span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h4 id="c-中编译器一定会给类生成默认构造函数吗"><a href="#c-中编译器一定会给类生成默认构造函数吗" class="headerlink" title="c++中编译器一定会给类生成默认构造函数吗"></a>c++中编译器一定会给类生成默认构造函数吗</h4><p>编译器会生成默认构造函数的几种情况:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/petersmart123/article/details/49207637">https://blog.csdn.net/petersmart123/article/details/49207637</a></p>
<p>只能指针</p>
<p>同顺会议用户</p>
<p>class A{int a; char c; void f(); virtual void v1(); virtual void v2();}</p>
<p>占多少个字节</p>
<p>A *p = NULL; p-&gt;f(); p-&gt;v2();</p>
<p>http 请求</p>
<p>长连接短链接</p>
<p>设计模式</p>
<p>stl源码</p>
<p>类里的内存分配,变量,函数,虚函数等等</p>
<h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><ul>
<li>公共权限 public          成员    类内可以访问    类外可以访问</li>
<li>保护权限 protected     成员    类内可以访问    类外不可以访问    子类可以访问父类中保护的内容</li>
<li>私有权限 private        成员    类内可以访问    类外不可以访问    子类不可以访问父类中私有的内容</li>
</ul>
<p>提到了上面这三个,那自然要讲讲继承的三种方式:</p>
<ul>
<li>公有继承    父类中的成员属性的访问权限不变.</li>
<li>保护继承    父类中的公有成员和保护成员都变成保护成员</li>
<li>私有继承    父类种的公有成员和保护成员都变成私有成员</li>
<li>c++中默认是私有继承</li>
<li>要注意的是,不管是哪种继承方式,父类中的私有成员都对子类不可见.</li>
</ul>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><ul>
<li>独有指针(unique_ptr)：只能有一个对象拥有这个所有权。</li>
</ul>
<p>手写类 实现对数据中类名、变量名、变量值的提取。</p>
<p>老师们好，我叫刘海峰，是来自山东大学的一名大四学生，成绩的话大概在年级的50%左右，会java，c++，php，python等语言的基本使用，然后也掌握了基本的web开发技术，数据库的话，在校学过mysql跟mongodb的基本使用。</p>
<p>工作意向：emmm工作地点我比较偏向于南方的城市，例如广州，因为我本人就是南方人，然后对南方的气候，饮食等会比较适应。</p>
<p>多重嵌套</p>
<p>java序列化</p>
<p>存储过程</p>
<p>视图</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/18/%E6%A0%91%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/%E6%A0%91%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">树习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-18 20:07:16 / 修改时间：20:36:17" itemprop="dateCreated datePublished" datetime="2020-08-18T20:07:16+08:00">2020-08-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="有序链表转换二叉搜索树"><a href="#有序链表转换二叉搜索树" class="headerlink" title="有序链表转换二叉搜索树"></a>有序链表转换二叉搜索树</h4><p>题目:</p>
<img src="/2020/08/18/%E6%A0%91%E4%B9%A0%E9%A2%98/image-20200818201044864.png" alt="image-20200818201044864" style="zoom:80%;">

<p>具体分析看leetcode代码注释,代码贴在这里记录下这个createBST(),特别的好.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(ListNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = getLen(head);</span><br><span class="line">        TreeNode* root = createBST(head,<span class="number">0</span>,len);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我们传入的是指针的引用,这点很重要!!!只有如此才能够通过递归不断的将node右移.从而遍历完整个链表.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">createBST</span><span class="params">(ListNode*&amp;node,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root-&gt;left = createBST(node,left,mid);</span><br><span class="line">        root-&gt;val = node-&gt;val;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        root-&gt;right = createBST(node,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/18/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" class="post-title-link" itemprop="url">时间复杂度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-18 16:10:16 / 修改时间：22:20:08" itemprop="dateCreated datePublished" datetime="2020-08-18T16:10:16+08:00">2020-08-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="主定理（Master-Theorem）与时间复杂度"><a href="#主定理（Master-Theorem）与时间复杂度" class="headerlink" title="主定理（Master Theorem）与时间复杂度"></a>主定理（Master Theorem）与时间复杂度</h3><hr>
<p><strong>主定理内容:</strong></p>
<p><img src="/2020/08/18/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/20160906163441303" alt="这里写图片描述"></p>
<p>logba指的是以b为底,a的对数.</p>
<p><strong>举例</strong></p>
<p>假设递归式子:T(n) = 2T(n/2)+n</p>
<p>那么a=2，b=2，所以logba=1，由由于f（n）=O（n）</p>
<p>所以f（n）=n（logba），所以T（n）= nlog n。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/13/%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/13/%E5%9B%BE/" class="post-title-link" itemprop="url">图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-13 23:58:23" itemprop="dateCreated datePublished" datetime="2020-08-13T23:58:23+08:00">2020-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-14 17:31:01" itemprop="dateModified" datetime="2020-08-14T17:31:01+08:00">2020-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图/Graph"></a>图/Graph</h3><hr>
<p><strong>基本知识点如下</strong></p>
<ul>
<li>阶、度（出度、入度）</li>
<li>树、森林、环</li>
<li>有向图、无向图、完全有向图、完全无向图</li>
<li>连通图、连通分量</li>
<li>图的存储和表达方式：邻接矩阵、临界列表</li>
</ul>
<p><strong>围绕图的算法也是各式各样</strong></p>
<ul>
<li>图的遍历：深度优先、广度优先</li>
<li>环的检测：有向图、无向图</li>
<li>拓扑排序</li>
<li>最短路径算法： Dijkstra、Bellman-Ford、Floyd Warshall</li>
<li>连通性相关算法： Kosaraju、Tarjan、求解孤岛的数量、判断是否为树</li>
<li>图的着色、旅行商问题等</li>
<li>还有很多…</li>
</ul>
<p><strong>必须熟练掌握的知识点</strong></p>
<ul>
<li>图的存储和表达方式：邻接矩阵、邻接列表</li>
<li>图的遍历：深度优先、广度优先</li>
<li>二部图的检测（Bipartite）、树的检测、环的检测：有向图、无向图</li>
<li>拓扑排序</li>
<li>联合-查找算法（Union-Find）</li>
<li>最短路径：Dijkstra、Bellman-Ford</li>
</ul>
<h4 id="深度优先遍历-DFS-和广度优先遍历-BFS"><a href="#深度优先遍历-DFS-和广度优先遍历-BFS" class="headerlink" title="深度优先遍历(DFS)和广度优先遍历(BFS)"></a>深度优先遍历(DFS)和广度优先遍历(BFS)</h4><hr>
<p>DFS和BFS的实现都比较简单,我们只要解用栈和队列两个数据结构就能很好的实现了.</p>
<p><strong>DFS</strong></p>
<ul>
<li>我们使用栈来实现DFS,因为DFS,要求我们从一个节点出发然后尽可能的把一条支路延申下去,而栈的FILO特性能很好的适配</li>
<li>首先我们将初始点纳入栈中,并且维护一个vector记录已入栈的点,然后在栈不为空的条件下开始以下操作</li>
<li>将栈顶元素出栈,然后找到与其相连的点,将其中还未入栈的点入栈。（栈顶元素必须先出栈，不然新元素加进来就出不了了）</li>
<li>重复上面的操作，直到栈为空，跳出循环。</li>
</ul>
<p><strong>BFS</strong></p>
<ul>
<li>BFS的实现跟DFS大同小异，我们使用队列来完成他，因为DFS要求我们从一个点出发，然后在访问与他相连的点，然后再访问与这些点相连的点，循环递进，最后把所有的点都辐射到，而队列FIFO的特性能很好的适配。</li>
<li>首先我们将初始点纳入队列中，并且维护一个vector记录已入队的点，然后再队列不为空的条件下开始以下操作</li>
<li>找到与队首元素相连的点，将其中未入队的点纳入队中，然后队首元素出队</li>
<li>重复上面操作，直到队列为空，跳出循环。</li>
</ul>
<h4 id="联合查找算法-并查集（Union-Find）"><a href="#联合查找算法-并查集（Union-Find）" class="headerlink" title="联合查找算法/并查集（Union-Find）"></a>联合查找算法/并查集（Union-Find）</h4><hr>
<p>使用并查集可以很轻松的解决一些图的问题,如找亲戚这种分类问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">并查集的类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root;</span><br><span class="line">    <span class="comment">//首先把k个点各自分为一类,把自身当作树节点。</span></span><br><span class="line">    UnionFind(<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;k;x++)&#123;</span><br><span class="line">            root.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断两点是否为一类，则判断他们的根节点是否一致。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//find方法用来找某个点的根节点，若该点就是根节点则返回原值，否则递归去寻找根节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root[i]==i) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="comment">//压缩路径，这样能把树的子节点的父节点更新为根节点。</span></span><br><span class="line">        <span class="keyword">return</span> root[i]=find(root[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个集合，只需将其中一个集合A对应的根节点接到另一个集合B对应的根节点上，相当于A成为B根节点下的子树</span></span><br><span class="line">    <span class="comment">//若是后续对A中元素使用find方法，因为压缩路径算法，A中的子节点也会逐渐的指向B的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        root[find(p)]=find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="二分图的判定"><a href="#二分图的判定" class="headerlink" title="二分图的判定"></a>二分图的判定</h4><hr>
<p><img src="/2020/08/13/%E5%9B%BE/image-20200814000112822.png" alt="image-20200814000112822"></p>
<p><strong>二分图特点</strong></p>
<ul>
<li>所有点被分成独立的两个集合</li>
<li>每条边的两个端点一定属于不同的集合</li>
<li>可能存在孤点</li>
<li>举例：正方形是一个二分图，而五边形不是二分图。</li>
</ul>
<p><strong>解法</strong></p>
<ul>
<li>转化成图着色问题<ul>
<li>BFS</li>
<li>DFS</li>
</ul>
</li>
<li>联合-查找算法/并查集（Union-Find）</li>
<li>总的来说就是分类，如果能按照二分图的特点分成两类，那么就是二分图，否则不是，上述两个方法都能实现这一思路。</li>
</ul>
<p><strong>如果让我们自己来判断一个图是不是二分图我们会怎么做呢？</strong></p>
<p>我的话会从一个点出发，把这个点放到A集合里，然后把与他相连的点放到B集合里，再把与这些点相连的点放回A集合，然后对新加入的点重复这个过程，若是在途中发现某个点既要放入A集合也要放入B集合，则说明该图不是二分图，否则则是一个二分图。</p>
<p>然后我们会发现这就是一个<strong>图着色</strong>的问题。</p>
<p><img src="/2020/08/13/%E5%9B%BE/image-20200814003831340.png" alt="image-20200814003831340"></p>
<p>而要想处理图着色，我们自然要对图进行<strong>遍历</strong>，而对图的遍历主要有两种方法：<strong>DFS</strong>和<strong>BFS</strong></p>
<p><img src="/2020/08/13/%E5%9B%BE/image-20200814004750635.png" alt="image-20200814004750635"></p>
<img src="/2020/08/13/%E5%9B%BE/image-20200814005159789.png" alt="image-20200814005159789" style="height:380px;width:900px;">

<p>(顺序不唯一，因为分支的选择不确定)</p>
<p>下面给出dfs的解题思路,bfs的解题思路也大同小异,只要将栈改为队列来做即可.:</p>
<img src="/2020/08/13/%E5%9B%BE/image-20200814094337192.png" alt="image-20200814094337192" style="zoom:80%;">

<p><strong>此外这个题除了用图着色的方法来解决，还可以用联合查找算法/并查集来解决：</strong></p>
<p>我们知道如果是二分图的话，那么图中每个顶点的所有邻接点都应该属于同一集合，且不与顶点处于同一集合。因此我们可以使用并查集来解决这个问题，我们遍历图中每个顶点，将当前顶点的所有邻接点进行合并，并判断这些邻接点中是否存在某一邻接点已经和当前顶点处于同一个集合中了，若是，则说明不是二分图。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/cpp%E4%B8%AD%E4%B8%80%E4%BA%9B%E8%9B%AE%E6%9C%89%E7%94%A8%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/cpp%E4%B8%AD%E4%B8%80%E4%BA%9B%E8%9B%AE%E6%9C%89%E7%94%A8%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">cpp中一些蛮有用的库函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-10 22:49:47" itemprop="dateCreated datePublished" datetime="2020-08-10T22:49:47+08:00">2020-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-24 21:14:18" itemprop="dateModified" datetime="2020-09-24T21:14:18+08:00">2020-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="这个博文用来记录我在刷题时-所遇到的一些蛮有用的库函数"><a href="#这个博文用来记录我在刷题时-所遇到的一些蛮有用的库函数" class="headerlink" title="这个博文用来记录我在刷题时,所遇到的一些蛮有用的库函数."></a>这个博文用来记录我在刷题时,所遇到的一些蛮有用的库函数.</h3><hr>
<p><strong>Sort()函数</strong></p>
<p>当我们引用了c++中algorithm的头文件时,我们就能用到这个函数拉,这是一个非常方便的排序函数，并且他的效率也是很高的，虽然我没有深入了解他的实现，但从网上搜索的结果来看，sort（）函数利用的时改进的快排算法，时间复杂度为O（nlogn），这是相当快的了，当然了，不要过分依赖它，偶尔也要自己手动写写各种排序算法才行呢。</p>
<p><strong>sort函数的模板有三个参数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个参数first：是要排序的数组的起始地址。</li>
<li>第二个参数last：是结束的地址（最后一个数据的后一个数据的地址）。</li>
<li>第三个参数cmp是排序的方法：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是从小到大排序（当然，sort（）只提供了对基本数据类型以及string等的默认比较方法，其他的例如用户自己定义的结构体或累,就需要自己手动编写比较算法啦）。</li>
</ol>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="comment">//sort函数第三个参数采用默认从小到大</span></span><br><span class="line">　　<span class="keyword">int</span> a[]=&#123;<span class="number">45</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">90</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">55</span>&#125;;</span><br><span class="line">　　sort(a,a+<span class="number">10</span>);</span><br><span class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">　　<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义排序</strong></p>
<p>sort()允许我们自定义排序,有以下几种方法:</p>
<p>(1)<strong>自定义比较函数cmp</strong></p>
<p>比如：</p>
<pre><code>bool  cmp(int a,int b)
&#123;
return b&lt;a;
&#125;

sort(a,a+n,cmp);</code></pre>
<p>传入的参数类型和需要排序的数据类型一致，如果认为第一个参数比第二个小，也就是第一个参数需要排在第二个参数前面时返回true，反之返回 false。系统默认a&lt;b时返回true，于是从小到大排。而上面的例子是当b小于a时，认为a小于b。所以排序的结果就是将元素按从大到小的顺序排序,要注意的是只能用&gt;或者&lt;,不能用&gt;=或&lt;=。</p>
<p>(2)<strong>重载比较运算符“&lt;”</strong></p>
<p>如：</p>
<pre><code>bool operator&lt; (const Student&amp; s1, const Student&amp; s2)
&#123;
if(s1.age==s2.age)    return s1.name &lt;s2.name;//年龄相同时，按姓名小到大排
else  return s1.age &gt; s2.age; //从年龄大到小排序
&#125;

sort(a,a+n);</code></pre>
<p>这里一定要注意一下：</p>
<p>参数类型如果是自定义类型，比如自己定义的结构体，类，尽管sort函数默认是从小到大排列，但是这里必须要在类中重载比较运算符“&lt;”,当然也可以用第一种方法。</p>
<p>和cmp函数同理，如果认为第一个参数比第二个小就返回true，反之返回 false。</p>
<p>(3)<strong>声明比较类</strong></p>
<pre><code>struct cmp
&#123;
    bool operator() (const Student&amp; s1, const Student&amp; s2)

   &#123;

          if(s1.age==s2.age)

                 return s1.name &lt;s2.name;

          else  return s1.age &lt; s2.age;

    &#125;</code></pre>
<p>};</p>
<p>sort(a,a+n,cmp());</p>
<p>还是同理，如果认为第一个参数比第二个小就返回true，反之返回 false。</p>
<p>(4) <strong>functional提供了一堆基于模板的比较函数对象</strong>：equal_to<Type>、not_equal_to<Type>、greater<Type>、greater_equal<Type>、less<Type>、less_equal<Type>。对于这个问题来说，greater和less就足够了，直接拿过来用：</Type></Type></Type></Type></Type></Type></p>
<p>升序：sort(begin,end,less<data-type>());</data-type></p>
<p>降序：sort(begin,end,greater<data-type>()。</data-type></p>
<p><mark>要注意的是:</mark>如果你是在类中定义的cmp()函数,并且想要在另一个类函数中用它当比较规则,那么必须将cmp()设为static,原因是当cmp()作为类函数时,实际上它含有这一个隐含的参数,即this指针,因此若用它来做比较函数,那么将会报错,解决方法就是将它定义为静态的static,亦或是把他定义在函数外,作为全局方法.</p>
<p><strong>建议使用第三种方法</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C/" class="post-title-link" itemprop="url">数据结构和算法学习(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-10 14:09:17" itemprop="dateCreated datePublished" datetime="2020-08-10T14:09:17+08:00">2020-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 22:40:39" itemprop="dateModified" datetime="2020-08-21T22:40:39+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="高级数据结构-Advanced-Data-Structure"><a href="#高级数据结构-Advanced-Data-Structure" class="headerlink" title="高级数据结构/Advanced Data Structure"></a>高级数据结构/Advanced Data Structure</h3><hr>
<ul>
<li><strong>优先队列</strong> / Priority Queue</li>
<li><strong>图</strong> / Graph</li>
<li><strong>前缀树</strong> / Tree</li>
<li><strong>线段树</strong> / Segment Tree</li>
<li><strong>树状数组</strong>/ Fenwick Tree / Binary Indexed Tree</li>
</ul>
<p>这些数据结构相对于前面我们学习的数据结构实现起来要复杂很多,但对我们在处理一些复杂问题时很有帮助,同时<strong>掌握好它们的性质,以及所适用的场合,在分析问题的时候回归本质,很多题目能够迎刃而解。</strong></p>
<h3 id="优先队列-Priority-Queue"><a href="#优先队列-Priority-Queue" class="headerlink" title="优先队列 / Priority Queue"></a>优先队列 / Priority Queue</h3><hr>
<p><strong>与普通队列的区别</strong></p>
<p>保证每次取出的元素时队列中优先级别最高的。</p>
<p>优先级别可自定义</p>
<p><strong>最常用场景</strong></p>
<p>从杂乱无章的数据中按照一定的顺序（或者优先级）筛选数据</p>
<p><strong>本质</strong></p>
<p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C/image-20200810174613059.png" alt="image-20200810174613059"></p>
<p>二叉堆（Binary Heap）的结构</p>
<p>利用一个数组结构来实现完全二叉树。</p>
<p>优先队列的本质是一个数组，数组里的每个元素既有可能是其他元素的父节点，也有可能是其他元素的子节点，而且每个父节点只能有两个子节点。</p>
<p><strong>特性</strong></p>
<p>数组里的第一个元素array[0]拥有最高的优先级</p>
<p>给定一个下标i，那么对于元素array[i]而言</p>
<ul>
<li>父节点对应的元素下标是（i-1）/2</li>
<li>左侧子节点对应的元素下标是2*i +1</li>
<li>右侧子节点对应的元素下标是2*i +2</li>
</ul>
<p>数组中每个元素的优先级都必须高于它两侧子节点。</p>
<p>因为是二叉堆结构，所以说每层的节点数是可知，稍加推导就可以得到上面所述的性质了。</p>
<p><strong>基本操作</strong></p>
<ul>
<li>向上筛选（sift up / bubble up）：当有新的数据加入到优先队列中，新的数据首先被放到二叉堆的底部，然后不断地对它进行向上筛选的操作，即<strong>如果发现其优先级别比其父节点的优先级别更高，则将其与其父节点相互交换，重复该过程，直到无法交换为止。由于二叉堆是一棵完全二叉树，假设堆的大小为k，因此整个过程实际上就是沿着树的高度往上爬，所以只需要O（log k）的时间</strong>。</li>
<li>向下筛选（sift down / bubble down）：当堆顶的元素被取出时，我们要更新堆顶的元素，来作为下一次按照优先顺序被取出的对象。 如何更新呢？<strong>首先我们将堆底部的元素放置到堆顶，然后不断地对其进行向下筛选的操作，即将该元素跟其两个孩子进行对比，如果优先级别最高的是某个孩子节点，则将该元素与那个孩子节点进行交换，重复该过程，直到无法交换为止。整个过程就是沿着树的高度往下爬，因此时间复杂度依旧是O（log k）。</strong></li>
<li><strong>因此，无论是添加新的数据还是取出堆顶的元素，都需要O（log k）的时间。</strong></li>
<li>另外一个最重要的时间复杂度：<strong>优先队列的初始化，这是分析运用优先队列性能是必不可少的，也是经常容易弄错的地方。</strong>假设我们有n个数据，我们需要创建一个大小为n的堆，乍一看，每当我们把一个数据加入到堆底，我们都要对它进行向上筛选的操作，这样一来，算法复杂度应该是O（n log n）。但是实际上我们在创建这个堆的过程中，<mark>二叉树的大小是从1逐渐增长到n的，所以整个算法的时间复杂度经过一些列数学推导（怎么推导的，没有细究）应该是O（n）。</mark></li>
</ul>
<p><strong>举例</strong></p>
<img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C/image-20200810195921881.png" alt="image-20200810195921881" style="zoom:80%;">

<p>这个题目并不难,题目说了要优于nlogn,实际上就是暗示我们用堆排序,因为哪怕是快排也需要nlogn而不是优于，而我们只需要维护一个大小为k的优先队列，就能在O（nlogk）里进行排序，当k较小的时候，时间复杂度是佷优的，但是如果k比较大的话，我们可以转换成删除k个频率最小的元素，使得算法复杂度变成O（nlog（n-k））。</p>
<p>解题思路：</p>
<ul>
<li>先用unordered_map 统计元素频率.</li>
<li>将他们放入到大小为k的priority_queue中,这一步需要我们自定义排序的方法,用下述方法自定义。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T a, T b)</span></span>&#123;...&#125;&#125;</span><br><span class="line"><span class="comment">//要注意的是,priority_queue默认使用&lt;来排序,默认容器是vector,也就是说优先级最大的元素实际上是在vector的尾部的。</span></span><br><span class="line"><span class="comment">//所以对基本数据类型，如果我们不自定义排序的话，它默认是大根堆。</span></span><br><span class="line"><span class="comment">//而如果我们使用greater&lt;T&gt;(),获得的实际上是一个小根堆.因为greater&lt;T&gt;()的定义如下</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line"><span class="comment">//而相反的less&lt;T&gt;()获得的是一个大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x&lt;y;&#125;</span><br><span class="line"><span class="comment">//我们自己自定义的时候,对于(T a,T b),如果希望b的优先级更大,那么就返回true,否则返回false.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要注意的是,当队列中元素为k时,新元素到来,我们则要将其于队首元素进行比较,如果队首元素的出现频率更小,那么队首元素出队,新元素push进队,否则新元素不仅队</li>
<li>等所有元素都处理过后,留在队中的元素就是出现频率最大的k个元素,之后我们将他逐一放到vector中即可.</li>
</ul>
<p>自己在用vector实现heap的时候,感觉向上筛选挺好实现的,但是向下的就蛮难了,因为向下的话不好确定临界条件.有点难受,明明我之前大二的时候实现过了,害我真是菜啊.</p>
<h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图/Graph"></a>图/Graph</h3><hr>
<p><strong>基本知识点如下</strong></p>
<ul>
<li>阶、度（出度、入度）</li>
<li>树、森林、环</li>
<li>有向图、无向图、完全有向图、完全无向图</li>
<li>连通图、连通分量</li>
<li>图的存储和表达方式：邻接矩阵、临界列表</li>
</ul>
<p><strong>围绕图的算法也是各式各样</strong></p>
<ul>
<li>图的遍历：深度优先、广度优先</li>
<li>环的检测：有向图、无向图</li>
<li>拓扑排序</li>
<li>最短路径算法： Dijkstra、Bellman-Ford、Floyd Warshall</li>
<li>连通性相关算法： Kosaraju、Tarjan、求解孤岛的数量、判断是否为树</li>
<li>图的着色、旅行商问题等</li>
<li>还有很多…</li>
</ul>
<p><strong>必须熟练掌握的知识点</strong></p>
<ul>
<li>图的存储和表达方式：邻接矩阵、邻接列表</li>
<li>图的遍历：深度优先、广度优先</li>
<li>二部图的检测（Bipartite）、树的检测、环的检测：有向图、无向图</li>
<li>拓扑排序</li>
<li>联合-查找算法（Union-Find）</li>
<li>最短路径：Dijkstra、Bellman-Ford</li>
</ul>
<p>具体内容看另外一篇博文—《图》</p>
<h3 id="前缀树-Trie"><a href="#前缀树-Trie" class="headerlink" title="前缀树/Trie"></a>前缀树/Trie</h3><p><strong>前缀树也称为字典树</strong></p>
<p>这种数据结构被广泛地运用到字典查找当中</p>
<p><strong>什么是字典查找？</strong></p>
<p>例如：给定一系列构成字典的字符串，要求在字典当中找出所有以“ABC”开头的字符串</p>
<ul>
<li>方法一：暴力搜索法。假设字典内单词为N,所要对比的开头平均长度为M,那么时间复杂度为O(M*N).</li>
<li>方法二:前缀树。时间复杂度O（M），M为字典里最长单词的字符个数。在大多数情况下N是远远大于M的。所以方法二的时间复杂度是远小于方法一的。</li>
</ul>
<p><strong>经典应用</strong></p>
<ul>
<li><p>搜索框输入搜索文字，会罗列以搜索词开头的相关搜索</p>
</li>
<li><p>汉语拼音输入法的联想输出功能也用到了前缀树。</p>
</li>
</ul>
<p><strong>重要性质</strong></p>
<ul>
<li>每个节点至少包含两个基本属性<ul>
<li>children：数组或者集合，罗列出每个分支当中包含的所有字符</li>
<li>isEnd：布尔值，表示该节点是否为某字符串的结尾</li>
</ul>
</li>
<li>前缀树的根节点是空的</li>
<li>除了根节点，其他所有节点都可能是单词的结尾，叶子节点一定都是单词的结尾。</li>
</ul>
<p><strong>最基本操作</strong></p>
<p><mark>具体实现见力扣208题</mark></p>
<p>创建</p>
<p><strong>方法</strong></p>
<ul>
<li>遍历一遍输入的字符串，对每个字符串的字符进行遍历</li>
<li>从前缀树的根节点开始，将每个字符加入到节点的Children字符集当中</li>
<li>如果字符集已经包含了这个字符，跳过。</li>
<li>如果当前字符是字符串的结尾，把当前节点的 isEnd 标记为真 </li>
<li>时间复杂度为O(n),n所有字符串的总长度</li>
</ul>
<p>搜索</p>
<p><strong>方法</strong></p>
<ul>
<li>从前缀树的根节点出发，逐个匹配输入的前缀字符</li>
<li>如果遇到了，继续往下一层搜索</li>
<li>如果没遇到，立即返回。</li>
<li>由此可见，如果树是按上面那种方法建立的话，树最长分支长度为最长字符串的长度M，所以通过前缀树来查一个字符串的时间复杂度为O（M）</li>
</ul>
<p><strong>举例</strong></p>
<p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C/image-20200818125209630.png"></p>
<p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C/image-20200818125530050.png" alt="image-20200818125530050"></p>
<p>这个题我们能够很容易想到用回溯</p>
<p>用回溯可以把所有的情况都走一便,但显然这样的时间复杂度和空间复杂度都太大了.</p>
<p>所以我们要想办法把一些不可能的情况给删除掉,或者说让回溯提早结束.</p>
<p>前缀树就能够很轻易的帮我们做到这一点.</p>
<p>解题思路</p>
<ul>
<li>我们根据words构建出一棵前缀树(如右图)<img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C/image-20200818125804528.png" alt="image-20200818125804528"></li>
<li>然后我们遍历board,当遍历的字符为[“o”,”p”,”e”,”r”]时即root对应的子节点.说明我们找到了一条有可能的起点.</li>
<li>于是我们要从该起点,设为(m,n)起进行dfs,同时此时我们要比对的应该是[“o”,”p”,”e”,”r”]对应的子树,假设该点对应’o’</li>
<li>那么接下来我们要判断(m,n)上下左右的临界点是否有值为’a’的点,若有则对该点dfs</li>
<li>重复这一过程,如果board存在words中的值,那么我们一定会遍历到。</li>
<li>此外，对于记得要维护一个visited记录我们访问过的点，以免无限递归。</li>
</ul>
<p><strong>关键代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">dfs</span><span class="params">(Trie* node,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">       <span class="keyword">if</span>(node-&gt;getEnd()) &#123;<span class="built_in">string</span> q=<span class="string">&quot;&quot;</span>;res.push_back(a[m][n]+q);&#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;<span class="number">4</span>;z++)&#123;</span><br><span class="line">           <span class="keyword">int</span> x = m+dx[z],y=n+dy[z];</span><br><span class="line">           <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;row&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;col&amp;&amp;done[x][y]==<span class="number">0</span>&amp;&amp;node-&gt;next[a[x][y]-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">               done[x][y] = <span class="number">1</span>;</span><br><span class="line">               <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp = dfs(node-&gt;next[a[x][y]-<span class="string">&#x27;a&#x27;</span>],x,y);</span><br><span class="line">               done[x][y] = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span>(<span class="built_in">string</span> s:temp)&#123;</span><br><span class="line">                   s = a[m][n]+s;</span><br><span class="line">                   res.push_back(s);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="线段树-Segment-Tree"><a href="#线段树-Segment-Tree" class="headerlink" title="线段树/Segment Tree"></a>线段树/Segment Tree</h3><hr>
<p><strong>先从一个例题出发</strong></p>
<p>假设我们有一个数组array[0…n-1],里面有n个元素,现在我们要经常对这个数组做两件事:</p>
<ol>
<li>更新数组元素的数值</li>
<li>求数组任意一段区间里元素的总和(或者平均值)</li>
</ol>
<p><strong>方法一</strong>:遍历一遍数组</p>
<p>时间复杂度O(n)–&gt;更新元素O(1)+遍历O(n)</p>
<p><strong>方法二</strong>:线段树</p>
<p>时间复杂度：O（logn）</p>
<p><strong>什么是线段树</strong></p>
<p>线段树是一种按照二叉树的形式存储数据的结构,每个节点保存的都是数组里某一段的总和。</p>
<p><strong>例如</strong></p>
<p>数组[1，3，5，7，9，11]，对应的线段树如下：</p>
<p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C/image-20200820143013042.png" alt="image-20200820143013042"></p>
<p>可以看出，根节点保存着所有元素的总和，而他的左右两个子节点分别储存左右两半元素的总和，按照这样的逻辑不断切分下去，最终叶子节点保存的就是每个元素的值。</p>
<p><strong>数组元素更新</strong></p>
<p>当我们要更新数组里某个元素时，我们从线段树的根节点出发，更新节点的值，因为他保存的是数组元素的总和，接下来，我们要从根节点往下，判断所修改元素的下标是在左半部分，还是右半部分，然后更新分支里的节点大小，按照这个逻辑不断更新下去，直到跟新到叶子节点，即存储该元素值的节点。</p>
<p>而上述这个过程就是沿着树的高度往下爬，所以复杂度是O（log n）</p>
<p><strong>对数组某区间段的元素进行求和</strong></p>
<p>方法与跟新方式类似，首先从根节点出发，判断所求区间是否落在节点所代表的区间当中，如果所要求的区间，完全包含了节点所代表的区间，那么就得加上该节点的数值 ，意味着该节点所储存的区间总和，只是我们要求的区间总和的一部分。接下来不断地往下寻找其他的子区间，最终得出我们要的总和。    </p>
<p>​    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/06/%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/06/%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">链表习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-06 20:56:42" itemprop="dateCreated datePublished" datetime="2020-08-06T20:56:42+08:00">2020-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-07 19:18:15" itemprop="dateModified" datetime="2020-09-07T19:18:15+08:00">2020-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%A0%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">习题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="这篇博文用来记录我刷的有关链表的习题"><a href="#这篇博文用来记录我刷的有关链表的习题" class="headerlink" title="这篇博文用来记录我刷的有关链表的习题."></a>这篇博文用来记录我刷的有关链表的习题.</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lhf_siven</p>
  <div class="site-description" itemprop="description">努力变成更好的自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/siven1987" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;siven1987" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lhf_siven@qq.com" title="E-Mail → mailto:lhf_siven@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lhf_siven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>-->
