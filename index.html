<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="努力变成更好的自己">
<meta property="og:type" content="website">
<meta property="og:title" content="lhf_siven">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lhf_siven">
<meta property="og:description" content="努力变成更好的自己">
<meta property="og:locale">
<meta property="article:author" content="lhf_siven">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>lhf_siven</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">lhf_siven</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/31/%E6%B1%87%E7%BC%96%E5%88%9D%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/31/%E6%B1%87%E7%BC%96%E5%88%9D%E5%AD%A6/" class="post-title-link" itemprop="url">汇编初学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-31 23:01:22" itemprop="dateCreated datePublished" datetime="2020-12-31T23:01:22+08:00">2020-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-29 16:12:35" itemprop="dateModified" datetime="2021-01-29T16:12:35+08:00">2021-01-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h4><p>C、C++、java都需要定义数据的类型，是因为计算机底层需要我们给这些数据定义宽度。</p>
<p>位(bit)        0 1</p>
<p>字节(byte)    0→0xFF</p>
<p>字(word)        0→0xFFFF     6位</p>
<p>双字(dword)    0→0xFFFFFFFF    32位</p>
<p>四字(qword)    0→0xFFFFFFFFFFFFFFFF    64位</p>
<h4 id="有符号数-无符号数"><a href="#有符号数-无符号数" class="headerlink" title="有符号数/无符号数"></a>有符号数/无符号数</h4><ul>
<li><p>无符号数规则：二进制数字是什么，那就是什么</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10011010 HEX:0x9A DEC:154 </span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>有符号数规则：最高位是符号位：1(负数)  0(正数)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10011010 如何转换？</span><br></pre></td></tr></table></figure>
</li>
<li><p>原码反码补码</p>
<p>有符号数的编码规则</p>
<ul>
<li><p>原码：最高位为符号位，剩下的位为该数的绝对值</p>
</li>
<li><p>反码：</p>
<ul>
<li>正数：与原码相同</li>
<li>负数：符号位一定是1，其余位对原码取反</li>
</ul>
</li>
<li><p>补码：</p>
<ul>
<li>正数:与原码相同</li>
<li>负数:符号位一定是1,对反码+1</li>
</ul>
</li>
<li><p>如果是正数,则三种编码规则一致.</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">测试(字长为8):</span><br><span class="line">1</span><br><span class="line"><span class="meta">#</span><span class="bash">原码    0 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">反码 0 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">补码 0 0 0 0 0 0 0 1</span></span><br><span class="line">-1</span><br><span class="line"><span class="meta">#</span><span class="bash">原码    1 0 0 0 0 0 0 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">反码 1 1 1 1 1 1 1 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">补码 1 1 1 1 1 1 1 1</span></span><br></pre></td></tr></table></figure>

<p>如果看到一个二进制的数字，需要了解它是有符号数还是无符号数，<strong>有符号数在计算机底层当中一般是按补码存储的</strong>。</p>
<p>寄存器：mov指令可以往寄存器中存值</p>
</li>
</ul>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><ul>
<li>与运算(and &amp;)</li>
<li>或运算(or |)</li>
<li>异或运算(xor ^)</li>
<li>非运算(单目运算符 not ~)</li>
<li>位运算(移动位)<ul>
<li>左移：(&lt;&lt;) 所有二进制位全部左移若干位,高位丢弃,低位补0.</li>
<li>右移: (&gt;&gt;) 所有二进制位全部右移若干位,低位丢弃,高位补0,1(符号位决定)</li>
</ul>
</li>
</ul>
<h4 id="位运算的加减乘除"><a href="#位运算的加减乘除" class="headerlink" title="位运算的加减乘除"></a>位运算的加减乘除</h4><p>加减乘除本质上都是加法.</p>
<p><strong>加法: 4+5</strong>?</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 计算机是怎么操作的?</span></span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">---------    人来做很简单就能算出来    </span><br><span class="line">0000 1001</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算机的实现</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一步: 异或. 如果不考虑进位,异或可以直接出结果</span></span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">---------- </span><br><span class="line">0000 0001</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二步: 与运算 (判断进位,如果与运算的结果为0,则没有进位)</span></span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">---------</span><br><span class="line">0000 0100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三步,将与运算的结果左移一位: 0000 1000 <span class="comment">#进位的结果</span></span></span><br><span class="line"></span><br><span class="line">第四步: 异或</span><br><span class="line">0000 0001</span><br><span class="line">0000 1000</span><br><span class="line">---------</span><br><span class="line">0000 1001</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">第五步: 与运算(判断进位)</span></span><br><span class="line">0000 0001</span><br><span class="line">0000 1000</span><br><span class="line">---------</span><br><span class="line">0000 0000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">当与运算的结果为0时,上一个异或运算的结果为最终结果.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 即4+5 = 0000 1001</span></span><br></pre></td></tr></table></figure>

<p><strong>减法:</strong></p>
<h5 id="补码的意义"><a href="#补码的意义" class="headerlink" title="补码的意义"></a>补码的意义</h5><p>对减法进行运算我们首先要明白什么是<strong>补码</strong>.</p>
<p>在介绍补码概念之前，先介绍一下<strong>“模</strong>”的概念：“模”是指一个计量系统的计数范围，如过去计量粮食用的斗、时钟等。计算机也可以看成一个计量机器，因为计算机的字长是定长的，即存储和处理的位数是有限的，因此它也有一个计量范围，即都存在一个“模”。如：时钟的计量范围是0~11，模=12。“模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。任何有模的计量器，均可化减法为加法运算,即取反后加1。</p>
<p>举个形象的例子:</p>
<p>现在有一个指向8点的闹钟需要校正到6点,那么有两种校正方法:</p>
<ul>
<li>顺时针拨10小时</li>
<li>逆时针拨2小时</li>
</ul>
<p>这里的顺时针跟逆时针拨发实际上就相当于加和减,即实现了如下操作:</p>
<p>8+10 = 12 + 6</p>
<p>8-2 = 6</p>
<p>10+2 = 12</p>
<p>由于时针的模为12,所以最终这两种拨发都可以使得时针指向正确的6点.</p>
<p>由上面这个例子我们可以看出,任何有模的计量器我们都可以使加一个数转化为减去相应的补数.</p>
<p><strong>把补数用到计算机对数的处理上，就是补码.</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1的补码</span></span><br><span class="line">0000 0001</span><br><span class="line"><span class="meta">#</span><span class="bash"> -1的补码</span></span><br><span class="line">1111 1111</span><br><span class="line">由此可见在补码的规则下,互为相反数的两个数的补码互为补数.因此我们在进行注入4-5这样的减法运算时,就可以转换为4+(-5)</span><br><span class="line">0000 0100 </span><br><span class="line">1111 1011</span><br><span class="line">---------    异或</span><br><span class="line">1111 1111</span><br><span class="line"></span><br><span class="line">0000 0100</span><br><span class="line">1111 1011</span><br><span class="line">---------    与运算</span><br><span class="line">0000 0000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因此 4-5 = 1111 1111 即-1</span></span><br></pre></td></tr></table></figure>

<p><strong>使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理.因为补码具有这种优良的特性,因而在计算机系统中,数值一律用补码来表示和存储.</strong></p>
<p>乘法：x*y，其本质就是y个x相加。</p>
<p>除法：x/y，本质就是x能减去多少个y。</p>
<p>综上，我们就了解了如何用位运算来进行加减乘除，其本质都是做加法。</p>
<h4 id="汇编语言环境说明"><a href="#汇编语言环境说明" class="headerlink" title="汇编语言环境说明"></a>汇编语言环境说明</h4><p>通过汇编指令可以给计算机发一些操作，然后让计算机执行。</p>
<p> 在学习汇编之前，大家需要先掌握环境的配置（1.vc6</p>
<p>（程序到汇编的理解) 2.OD 3.抓包工具 4.加密解密工具)</p>
<p>学汇编不是为了写代码,而是去理解程序的本质.</p>
<p>建议直接学习32位汇编</p>
<p>汇编入门：了解汇编和程序的对应关系，程序的本质即可。</p>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 32位CPU的通用寄存器只有8个</span></span><br><span class="line">EAX</span><br><span class="line">ECX</span><br><span class="line">EDX</span><br><span class="line">EBX</span><br><span class="line">ESP</span><br><span class="line">EBP</span><br><span class="line">ESI</span><br><span class="line">EDI</span><br><span class="line"><span class="meta">#</span><span class="bash"> 存值范围0~FFFFFFFF</span></span><br></pre></td></tr></table></figure>

<p><strong>mov指令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以将数字写入到寄存器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以将一个寄存器中的值写到另一个寄存器中 </span></span><br></pre></td></tr></table></figure>



<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><h4 id="内存复制"><a href="#内存复制" class="headerlink" title="内存复制"></a>内存复制</h4><h4 id="汇编如何写函数"><a href="#汇编如何写函数" class="headerlink" title="汇编如何写函数"></a>汇编如何写函数</h4><h4 id="堆栈传参"><a href="#堆栈传参" class="headerlink" title="堆栈传参"></a>堆栈传参</h4><h4 id="堆栈平衡"><a href="#堆栈平衡" class="headerlink" title="堆栈平衡"></a>堆栈平衡</h4><h4 id="外挂"><a href="#外挂" class="headerlink" title="外挂"></a>外挂</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/01/%E6%B5%AA%E6%BD%AE-%E5%86%B2%E6%B5%AA%E8%AE%A1%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/%E6%B5%AA%E6%BD%AE-%E5%86%B2%E6%B5%AA%E8%AE%A1%E5%88%92/" class="post-title-link" itemprop="url">浪潮-冲浪计划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 21:25:01" itemprop="dateCreated datePublished" datetime="2020-12-01T21:25:01+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 14:46:02" itemprop="dateModified" datetime="2020-12-02T14:46:02+08:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="职业规划与职业价值观塑造"><a href="#职业规划与职业价值观塑造" class="headerlink" title="职业规划与职业价值观塑造"></a>职业规划与职业价值观塑造</h3><ul>
<li>一开始做什么不重要,重要的是想好自己想做什么。</li>
<li>无论做什么事情，只要用心，总是有办法的。</li>
<li>常反思总结，看看自己有什么问题。</li>
<li>懂得更多，才知道自己懂得不够多。</li>
<li>浪潮企业文化：踏实的做事情。</li>
<li>做好知识的储备，多读书。</li>
</ul>
<p><img src="/2020/12/01/%E6%B5%AA%E6%BD%AE-%E5%86%B2%E6%B5%AA%E8%AE%A1%E5%88%92/image-20201202143738597.png" alt="image-20201202143738597"></p>
<p>​    bpic</p>
<p><img src="/2020/12/01/%E6%B5%AA%E6%BD%AE-%E5%86%B2%E6%B5%AA%E8%AE%A1%E5%88%92/image-20201202144200428.png" alt="image-20201202144200428"></p>
<p><img src="/2020/12/01/%E6%B5%AA%E6%BD%AE-%E5%86%B2%E6%B5%AA%E8%AE%A1%E5%88%92/image-20201202144601718.png" alt="image-20201202144601718"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/12/java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/12/java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="post-title-link" itemprop="url">java面试准备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-12 22:21:55" itemprop="dateCreated datePublished" datetime="2020-10-12T22:21:55+08:00">2020-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-14 15:34:58" itemprop="dateModified" datetime="2020-10-14T15:34:58+08:00">2020-10-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><ol>
<li><p>TCP协议的拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。常用的方法有:</p>
<ul>
<li>慢开始、拥塞控制</li>
<li>快重传、快恢复</li>
</ul>
</li>
</ol>
<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><ol>
<li><p>bash脚本文件一般第一行开头是：**#!**。</p>
</li>
<li><p>在bash编程中,算术比较大于、大于等于的运算符是：<strong>ge</strong>、<strong>gt</strong></p>
</li>
</ol>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ol>
<li><p>Object类中的方法：wait,clone,equals,hashCode,toString,getClass,notify,finalize</p>
</li>
<li><p>ArrayList初始容量为10,扩容*1.5（向下取整），所以存100个值需要扩6次。</p>
</li>
<li><p>对类的主动使用：</p>
<ul>
<li><p>创建类的实例</p>
</li>
<li><p>访问某个类或者接口的静态变量，或者对该静态变量赋值。</p>
</li>
<li><p>调用类的静态方法。</p>
</li>
<li><p>反射（Class.forName（&ldquo;&rdquo;））</p>
</li>
<li><p>初始化类的子类</p>
</li>
<li><p>java虚拟机启动时被标明为启动类的类</p>
</li>
<li><p>注意:<code>Class clazz=classLoader.loadClass(&quot;A&quot;);</code>是加载class文件到内存中，并没有对类进行首次主动使用，所以没有初始化,静态代码块的代码也不会执行，静态代码块的内容实在下图初始化阶段执行的。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/czwbig/p/11127222.html%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%82">https://www.cnblogs.com/czwbig/p/11127222.html：深入理解类加载机制。</a></strong></p>
</li>
</ul>
<p><img src="/2020/10/12/java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/image-20201013092305981.png" alt="image-20201013092305981"></p>
<p><strong>注意</strong>：</p>
<ol>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
<li>通过数组定义来引用类，不会触发此类的初始化。<code>MyClass[] cs = new MyClass[10];</code></li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.interview;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        B[] b = <span class="keyword">new</span> B[<span class="number">5</span>];</span><br><span class="line">        System.out.print(B.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String c = <span class="string">&quot;C&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">        C</span></span><br><span class="line"><span class="comment">    1. 用数组定义引用类,并不引发初始化</span></span><br><span class="line"><span class="comment">    2. 常量不引发初始化,因为它在编译阶段便被存储在常量池中,本质上并没有直接引用到定义常量的类.如果去掉A中的c的final修饰符,那么A类会被初始化,结果会变成AC,但是B类依旧不会初始化,因为是通过子类来引用父类的静态字段.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//稍微改改A和B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> String c = <span class="string">&quot;C&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    ABC</span></span><br><span class="line"><span class="comment">    因为调用了B中的静态变量,所以B类初始化,由于B类要初始化所以A类也要初始化,且在B类前,所以A,B的依次初始化,最终结果ABC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//再稍微改改A和B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String c = <span class="keyword">new</span> String(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    AC</span></span><br><span class="line"><span class="comment">    尽管c被final修饰,但是它的值要等到执行new String(&quot;C&quot;)才会被赋予,而堆上的操作,是要等到初始化阶段才行,所以这里依旧会加载A类.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串比较</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">    &quot;==&quot;判断的是引用所指向的地址,而equals比较的是引用指向的地址中所存储的值.</span></span><br><span class="line"><span class="comment">    执行语句2的时候首先会看常量池中是否有&quot;abc&quot;,有的话则s1指向对应地址,没有的话则开辟一个内存存储&quot;abc&quot;</span></span><br><span class="line"><span class="comment">    执行语句3时,常量池中肯定有&quot;abc&quot;的内存,所以s2直接指向该内存,故s2和s1所指向的地址相同.</span></span><br><span class="line"><span class="comment">    故s1==s2为true</span></span><br><span class="line"><span class="comment">    执行语句5时,遇到new关键字,在堆上开辟一块新内存存放&quot;abc&quot;,所以s3指向一块新内存.</span></span><br><span class="line"><span class="comment">    故s1==s3为false.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>java中int与Integer用==比较详解</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/andyzhaojianhui/article/details/84324466">https://blog.csdn.net/andyzhaojianhui/article/details/84324466</a></p>
</li>
<li><p>String、StringBuffer和StringBuilder的区别：</p>
<ul>
<li><p>String跟其他两个类的区别是：String是final类型，每次声明的都是不可变的对象，所以每次操作都会产生新的String对象，然后将指针指向新的String对象。而StringBuffer和StringBuilder都是在原有对象上进行操作，所以如果需要经常改变字符串内容，建议采用这两者。</p>
</li>
<li><p>线程安全：StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 synchronized 修饰。</p>
</li>
<li><p>性能：既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。</p>
</li>
<li><p>总的来说StringBuffer适用于多线程数据量较大的，StringBuilder适用于单线程数据量要求较大的。</p>
</li>
</ul>
</li>
<li><p>谈谈你对面向对象思想的理解：</p>
<p>   我觉得这两者是思想角度的差异，面向过程更多是以“执行者”的角度来思考问题，而面向对象更多是以“组织者”的角度来思考问题，举个例子：比如我要产生一个0-10之间的随机数，如果以“面向过程”思维，那我更多的关注如何去设计一个算法，然后保证比较均衡产生0-10的随机数，而面向对象的思维会更多去关注，我找谁来帮我们做这件事，比如Random类，调用其中提供的方法即可。</p>
<p>   所以面向对象的思维更多的是考虑如何去选择合适的工具，然后组织到一起干一件事。</p>
</li>
<li><p>==和equals的区别</p>
<ul>
<li>== 比较的是值，比较基本的数据类型时，比较的是数值，比较引用类型时：比较的是引用指向的值（地址）</li>
<li>equals默认比较也是地址，因为这个方法最初定义在Object上，默认的实现就是比较地址。自定义的类，如果需要比较的是内容，就要学String类，重写equals方法。</li>
</ul>
</li>
<li><p>final</p>
<ul>
<li>修饰类：表示类不可变，不可继承</li>
<li>修饰方法：表示该方法不可重写</li>
<li>修饰变量：表示该变量是常量</li>
<li>注意：修饰的是基本数据类型时，表示这个值本身不能被修改，修饰的时引用类型时，表示引用到指向不能修改，但是所指向的地址上存储的值是可以变的。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/22/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-22 21:34:36" itemprop="dateCreated datePublished" datetime="2020-09-22T21:34:36+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 00:08:45" itemprop="dateModified" datetime="2020-09-23T00:08:45+08:00">2020-09-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="DOS-Disk-Operating-System"><a href="#DOS-Disk-Operating-System" class="headerlink" title="DOS(Disk Operating System)"></a>DOS(Disk Operating System)</h4><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#盘符切换    E:</span></span><br><span class="line"><span class="comment">#查看当前目录下所有文件    dir</span></span><br><span class="line"><span class="comment">#切换目录</span></span><br><span class="line"><span class="built_in">cd</span> (change directory)</span><br><span class="line">+ <span class="built_in">cd</span> /d 路径    (跨盘切换)</span><br><span class="line">+ <span class="built_in">cd</span>.. (返回上级目录)</span><br><span class="line">+ <span class="built_in">cd</span> 目录名 (切换下级目录)</span><br><span class="line"><span class="comment">#清理屏幕    cls</span></span><br><span class="line"><span class="comment">#退出终端    exit</span></span><br><span class="line"><span class="comment">#查看电脑的ip ipconfig</span></span><br><span class="line"><span class="comment">#打开应用</span></span><br><span class="line">    calc    计算器</span><br><span class="line">    mspaint    画图</span><br><span class="line">    notepad    记事本</span><br><span class="line"><span class="comment">#ping 命令    可以获取对应网站的ip,也可以测试网络链接</span></span><br><span class="line">    ping www.baidu.com </span><br><span class="line"><span class="comment">#新建文件夹 md 目录名</span></span><br><span class="line"><span class="comment">#新建文件    cd&gt; 文件名</span></span><br><span class="line"><span class="comment">#删除文件 del 文件名</span></span><br><span class="line"><span class="comment">#删除文件夹 rm 目录名</span></span><br><span class="line">&lt;!--注意上述命令都得在对应的路径下执行--&gt;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/22/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="post-title-link" itemprop="url">常用快捷键</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-22 21:29:59" itemprop="dateCreated datePublished" datetime="2020-09-22T21:29:59+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-10 21:58:08" itemprop="dateModified" datetime="2020-12-10T21:58:08+08:00">2020-12-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><hr>
<ul>
<li><p>win+E→打开我的电脑</p>
</li>
<li><p>ctrl+shift+esc→打开任务管理器</p>
</li>
<li><p>shift+delete→永久删除</p>
</li>
<li><p>Tab/Shift+Tab：选中文字区域按Tab可以整体加一个缩进，按Shift+Tab可以消除缩进（部分编辑器为减少一个缩进）</p>
</li>
</ul>
<h4 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h4><hr>
<ul>
<li><p>Alt+Insert：自动生成构造方法，Getter，Setter，tostring等一系列常用的类成员函数。</p>
</li>
<li><p>Ctrl + H：可以查看类的继承关系。</p>
</li>
<li><p>Ctrl+Alt+T：选中代码按快捷键可以快速在代码外面添加诸如if else，try catch等处理，具体如下：</p>
</li>
</ul>
<p><img src="/2020/09/22/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/image-20201011191126891.png" alt="image-20201011191126891"></p>
<ul>
<li><p>Ctrl + Alt + Enter：向上插入空行</p>
</li>
<li><p>Shift + Enter：向下插入空行</p>
</li>
<li><p>Ctrl + Shift + /：多行注释</p>
</li>
<li><p>按住Alt键可以实现竖直方向上的选中文本。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/22/java%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/java%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">java学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-22 21:18:49" itemprop="dateCreated datePublished" datetime="2020-09-22T21:18:49+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-31 22:54:28" itemprop="dateModified" datetime="2020-12-31T22:54:28+08:00">2020-12-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><ul>
<li><p>当我们写一个很大的数的时候,例如1000000000,十亿,在java中我们可以用下划线来切割</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="comment">//这样写就不容易写错了,这是JDK7的新特性</span></span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="java">//在idea中可以利用100.for的快捷输入来生成for循环次数为100的模板。
for (int i = 0; i &lt; 100; i++) &#123;

&#125;
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## JavaSE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 基础知识&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 特性和优势&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 简单性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 面向对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 可移植性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 高性能&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 分布式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 动态性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 多线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 安全性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 健壮性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### Java三大版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+  Write Once、Run Anywhere&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JavaSE：标准版（桌面程序，控制台开发）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JavaME：嵌入式开发（手机，小家电）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JavaEE：：E企业级开发（web端，服务器开发）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### JDK、JRE、JVM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JDK：Java Development Kit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JRE：Java Runtime Environment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ JVM：Java Virtual Machine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;![image-20200923200112627](java学习&amp;#x2F;image-20200923200112627.png)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;根据上图可以看出三者之间的关系。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 卸载JDK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. 删除java的安装目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 删除JAVA_HOME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 删除path下关于java的目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. cmd下java -version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 安装JDK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;百度教程，下载JDK8就好了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### JAVA程序运行机制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 编译型(以看外文书为例,看之前先翻译好)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 解释性(请一个翻译员,看一句翻译一句)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 一般的语言的运行机制是上面的两种之一,二者各有好处,前者一次编译,执行效率就比较高,但是如果代码有所改动的话需要再次编译,而后者不需要但是后者的运行效率没那么高,因为是边执行边编译.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;![image-20200924150625592](java学习&amp;#x2F;image-20200924150625592.png)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java的运行机制是二者皆有,先编译成字节码,在通过解释器解释给操作系统&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;随着项目的规模扩张,我们有时候翻看之前的代码的时候可能会阅读的比较困难,因此注释的存在就很有必要了.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**java中的注释有三种**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 单行注释(&amp;#x2F;&amp;#x2F;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 多行注释(&amp;#x2F;**&amp;#x2F;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 文档注释(&amp;#x2F;**  *&amp;#x2F;,以&amp;#x2F;***开头)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 标识符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 关键字：Java中事先定义的，有特别意义的标识符，有时又叫保留字，关键字不能用作变量名、方法名、类名、包名和参数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ![image-20200925171124073](java学习&amp;#x2F;image-20200925171124073.png)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ Java中所有的组成部分都需要名字。类名、变量名以及方法名等都被称为标识符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 规则：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 所有的标识符都应该以字母、美元符号&amp;#39;$&amp;#39;、下划线&amp;#39;_&amp;#39;开始。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 首字母后可以是字母、美元符号、下划线、数字的任意字符组合。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 不能使用关键字作为变量名或方法名、类名。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 标识符是大小敏感的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 可以使用中文命名，但是一般不建议。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 数据类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**强类型语言**：要求变量的使用要严格符合规定，所有变量都必须先定义，才能够使用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**弱类型语言**：无需事先声明变量类型。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前者安全，后者效率高，各有取舍，对应了不同的应用场景。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**Java的数据类型分为两大类**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 基本数据类型（primitive type）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 数值类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    + 整数类型：byte：1字节，short：2字节，int：4字节，long：8字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    + 浮点类型：floate：4字节，double：8字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    + 字符类型：char：2字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + boolean类型：1个字节，只有false和true两个值。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ 引用数据类型（reference type）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + 数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 数据类型扩展&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**整数扩展**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#96;&amp;#96;&amp;#96;java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;整数扩展: 进制  二进制0b   十进制 八进制0 十六进制0x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i0 &amp;#x3D; 0b10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i1  &amp;#x3D; 10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i2 &amp;#x3D; 010;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i3 &amp;#x3D; 0x10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(&amp;quot;&amp;quot;+i0+&amp;#39;\t&amp;#39;+i1+&amp;#39;\t&amp;#39;+i2+&amp;#39;\t&amp;#39;+i3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;输出:2    10    8    16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
</li>
</ul>
<p><strong>浮点数扩展</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    浮点数的存储形式决定了它只能是一个离散的值,与我们实际想要得到的值存在误差.</span></span><br><span class="line"><span class="comment">    因此我们应避免使用浮点数来进行比较,如果实在需要比较,那么需要也只能在某一个范围内比较,这个范围取决于精度,</span></span><br><span class="line"><span class="comment">    也就是误差能容忍的范围.</span></span><br><span class="line"><span class="comment">    但有些地方要求数据是很精确的,例如银行.</span></span><br><span class="line"><span class="comment">    此时我们就要使用BigDecimal,是Java中预设的一个数学工具类.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>字符扩展</strong></p>
<p>所有的字符本质还是数字,可以用(int)进行强制转换</p>
<p><strong>字符串扩展</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line">String s3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s4 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s3==s4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">造成这种输出差异的原因在于内存分配.</span></span><br><span class="line"><span class="comment">首先我们要知道s1,s2,s3,s4都是类对象,都是引用数据类型,它们指向了内存中的一块区域,而它们本身被存储在栈内存中.</span></span><br><span class="line"><span class="comment">对于s1和s2它们指向的内存是由new开辟出来的内存,位置在堆内存中,且相互独立.</span></span><br><span class="line"><span class="comment">而s3和s4指向的&quot;hello&quot;,则是被放在了常量池当中.</span></span><br><span class="line"><span class="comment">而引用类型的比较,是比较它们所指向的地址,因此s1==s2为false,s3==s4为true;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h4><p>栈区：存放局部变量（变量名，对象的引用等）特点：内存随着函数的调用而开辟，随着函数调用结束而释放。</p>
<p>堆区：存放对象（也就是new出来的东西）特点：可以跨函数使用，每个对象有自己对应的存储空间。</p>
<p>静态域：存放在对象中用static定义的静态成员。</p>
<p>常量池：存放常量。（常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。）</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li><p>由于Java是强类型语言,所以要进行有些运算的时候,需要用到类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//低 ---------------------------&gt; 高</span></span><br><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>-&gt;<span class="keyword">int</span>-&gt;<span class="keyword">long</span>-&gt;<span class="keyword">float</span>-&gt;<span class="keyword">double</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">+ <span class="keyword">byte</span> b = i; <span class="comment">//错误</span></span><br><span class="line">+ <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;<span class="comment">//正确</span></span><br><span class="line">+ <span class="keyword">boolean</span> b = (<span class="keyword">boolean</span>) i;<span class="comment">//错误    </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运算中，不同类型的数据先转化为同一类型，然后进行运算。</p>
</li>
<li><p>强制类型转换：（类型）变量名  高-&gt;低</p>
</li>
<li><p>自动类型转换：低 -&gt; 高</p>
</li>
<li><p>注意点</p>
<ol>
<li>不能对布尔值进行转换。</li>
<li>不能把对象类型转换为不相干的类型。</li>
<li>在把高容量转换到低容量的时候，强制转换。</li>
<li>转换到时候可能存在内存溢出，或者精度问题。 </li>
</ol>
</li>
</ul>
<ol start="5">
<li>short,byte,char等类型之间（包括同类型内）的运算,会自动转化成int型。</li>
</ol>
<ul>
<li>对于上面第4点的内存溢出,比较好想到的是大容量转化为低容量强制转换时的情况,但实际上低容量转化为大容量,自动转换是也有可能发生,但与前面的有些不同,举个例子:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">long</span> y = a*i;</span><br><span class="line">System.out.println(y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:-1474836480</span></span><br><span class="line"><span class="comment">//可以看出由于a和i都是int型,因此a*i是按4个字节来算的,因此结果溢出,在已经溢出的情况下转化为long,值依旧是不正确的.</span></span><br><span class="line"><span class="comment">//正确的做法应该是将a*i改成(long)a*i,让他们按long的规则来算.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>变量：可以变化的量。</li>
<li>Java是一种强类型语言，每个变量都必须声明其类型。</li>
<li>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type varName [=value] [&#123;,varName[=value]&#125;];</span><br><span class="line"><span class="comment">//数据类型    变量名 = 值;可以使用逗号隔开来声明多个同类型变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项:<ul>
<li>每个变量都有类型，类型可以是基本类型，也可以是引用类型。</li>
<li>变量名必须是合法的标识符。</li>
<li>变量声明是一条完整的语句，因此每一个声明都必须以分号结束。</li>
</ul>
</li>
</ul>
<p><strong>变量类型</strong></p>
<ul>
<li>类变量</li>
<li>实例变量</li>
<li>局部变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">variable</span></span>&#123;</span><br><span class="line">       <span class="comment">//下面这两个变量都是成员变量。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> allClicks = <span class="number">0</span>; <span class="comment">//类变量（由static关键字修饰）</span></span><br><span class="line">    String str;    <span class="comment">//实例变量，从属于对象；如果不自行初始话，会初始化为这个类型的默认值：0（整数类型），0.0（浮点数类型），u0000（字符类型），布尔值：默认是false；除了基本类型其余的默认值都是null；</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">//局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常量</strong></p>
<ul>
<li>常量（Constant）：初始化（initialize）后不能再改变值，不会变动的值。</li>
<li>所谓的常量可以理解成一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 常量名 = 值;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//常量用final关键字修饰.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常量名一般使用大写字符。</li>
</ul>
<p><strong>变量的命名规范</strong></p>
<ul>
<li>所有变量、方法、类名：<strong>见名知意</strong></li>
<li>类成员变量：首字母小写和驼峰原则（除了第一个单词以外，此后的所有单词首字母大写）：monthSalary</li>
<li>局部变量：首字母小写和驼峰原则</li>
<li>常量：大写字母和下划线：MAX_VALUE</li>
<li>类名：首字母大写和驼峰原则：Man，GoodMan(<strong>只有这个是首字母大写</strong>)</li>
<li>方法名：首字母小写和驼峰原则：run(),runRun()</li>
</ul>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul>
<li><p>Java语言支持如下运算符：</p>
<ul>
<li>算数运算符：+，-，*，/，%，++，–</li>
<li>赋值运算符：=</li>
<li>关系运算符：&gt;,&lt;,&gt;=,&lt;=,==,!= instanceof</li>
<li>逻辑运算符：&amp;&amp;，||，！</li>
<li>位运算符：&amp;，|，^，~，&gt;&gt;(/2)，&lt;&lt;(*2)，&gt;&gt;&gt;（了解）</li>
<li>条件运算符：? :</li>
<li>扩展运算符：+=，-=，*=，/=</li>
</ul>
</li>
<li><p>其他一些高级点的运算，例如幂运算，在Java中可以借用工具类Math中的pow(底数,指数)函数来实现，Math类中有很多实用的方法。</p>
</li>
</ul>
<h4 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h4><ul>
<li><p>为了更好地组织类，Java提供了包机制，用于区别类名的命名空间。</p>
</li>
<li><p>包语句的语法格式为：</p>
<p><code>package pkg1[. pkg2[. pkg3...]];</code></p>
</li>
<li><p>一般利用公司域名倒置作为包名；</p>
</li>
<li><p>为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包，使用“import”语句可以完成此功能。</p>
<p><code>import package[.package2...].(classname|*);</code></p>
</li>
<li><p>package必须放在最上面，import语句不能在它之前。</p>
</li>
</ul>
<h4 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h4><ul>
<li>JavaDoc命令是用来生成自己的API文档的（javadoc -encoding UTF-8 -charset UTF-8 package.xxx.java)</li>
<li>上面这个使用命令行生成javadoc,idea也有自带的方法生成,具体位置在tool-&gt;generate Javadoc,详细参数见百度.</li>
<li>参数信息<ul>
<li>@author 作者名</li>
<li>@version 版本号</li>
<li>since 指明需要最早使用的jdk版本（即多少版本后的jdk可以使用）</li>
<li>@param 参数名</li>
<li>@return 返回值情况</li>
<li>@throws 异常抛出情况</li>
</ul>
</li>
</ul>
<h4 id="Java流程控制"><a href="#Java流程控制" class="headerlink" title="Java流程控制"></a>Java流程控制</h4><hr>
<h4 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h4><ul>
<li><p><strong>java.util.Scanner使Java5的新特性,我们可以通过Scanner类来获取用户的输入。</strong></p>
<p><code>Scanner s = new Scanner(System.in);</code></p>
</li>
<li><p>通过Scanner类的next()与nextLine()方法获取输入的字符串,在读取前我们一般需要使用hasNext()与hasNextLine()判断是否还有输入的数据。</p>
</li>
<li><p>next():</p>
<ol>
<li>一定要读取到有效字符后才可以结束输入</li>
<li>对输入有效字符之前遇到的空白,next()方法会自动将其去掉</li>
<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符</li>
<li><strong>next()不能得到带有空格的字符串</strong></li>
</ol>
</li>
<li><p>nextLine():</p>
<ol>
<li>以Enter为空格符,也就是说nextLine()方法返回的使输入回车之前的所有字符（包括有效字符前的空白）</li>
<li>可以获得空白。</li>
</ol>
</li>
</ul>
<h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><ul>
<li>Java的基本结构就是顺序结构,除非特别指明,否则就按照顺序一句一句执行。</li>
<li>顺序结构使最简单的算法结构。</li>
<li>顺序结构使由若干个依次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构。</li>
</ul>
<h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><ul>
<li><p>if单选择结构    if(){}</p>
</li>
<li><p>if双选择结构    if(){}else{}</p>
</li>
<li><p>if多选择结构    if(){}else if(){}…else{}</p>
</li>
<li><p>嵌套的if结构    if(){if(){…}}</p>
</li>
<li><p>switch多选择结构：switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value <span class="number">2</span>:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch语句中的变量类型可以是：</p>
<ul>
<li>byte、short、int或者char</li>
<li>从JavaSE 7开始</li>
<li>switch支持字符串String类型</li>
<li>同时case标签必须为字符串常量或者字面量，具体实现是因为每个字符串的本质其实就是hashcode，也就是数字，我们可以通过将对应的class文件放入到java文件同目录下，可以通过idea自带的反编译功能，去观测到编译器为我们做的一些工作。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20200930210910783.png" alt="image-20200930210910783"></p>
<p>比如上图，我们可以看到当switch匹配字符串的时候，编译器其实将其转换成了对应hashcode的比较。 </p>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul>
<li><p>while循环    while(布尔表达式){}</p>
</li>
<li><p>do…while 循环 do{//代码语句}while(布尔表达式)；与while循环不同的是，do…while循环至少执行一次，前者是先判断后执行，后者是先执行后判断。</p>
</li>
<li><p>for循环</p>
<ul>
<li><p>for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。</p>
</li>
<li><p>for循环执行的次数是在执行前就确定的。语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化;布尔表达式;更新)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在idea中可以利用100.for的快捷输入来生成</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>最先执行初始化步骤，可以声明一种类型，但可以初始化一个或多个循环控制变量，也可以是空语句。布尔表达式和更新都可以是空语句，但这样的for循环就会变成了死循环。</p>
</li>
<li><p>在Java5中引入了一种主要用于数组的增强型for循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句:表达式)&#123;</span><br><span class="line">    <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break&amp;continue"></a>break&amp;continue</h4><ul>
<li><p>break：在任何循环语句的主体部分，均可用break控制循环的流程。break用于强制退出循环，不执行循环中的剩余的语句。（break语句也可在switch语句中使用）</p>
</li>
<li><p>continue：用在循环语句体中，用于终止某次循环过程，即跳过本次循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</p>
</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20200930220555417.png" alt="image-20200930220555417"></p>
<h3 id="Java方法详解"><a href="#Java方法详解" class="headerlink" title="Java方法详解"></a>Java方法详解</h3><hr>
<ul>
<li>Java方法是语句的集合，它们在一起执行一个功能。<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
</li>
<li>设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保证方法的原子性，<strong>就是一个方法只完成一个功能，这样有利于我们后期的扩展。</strong></li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20200930223720864.png" alt="image-20200930223720864"></p>
<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><ul>
<li>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</li>
<li>方法重载的规则：<ul>
<li>方法名称必须相同。</li>
<li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）</li>
<li>方法的返回类型可以相同也可以不同，不影响。</li>
</ul>
</li>
<li>实现理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li>
</ul>
<h4 id="可变参-不定项-数"><a href="#可变参-不定项-数" class="headerlink" title="可变参(不定项)数"></a>可变参(不定项)数</h4><ul>
<li>JDK1.5开始，Java支持传递同类型的可变参数给一个方法。</li>
<li>在方法声明中，在指定参数类型后加一个省略号(…)。</li>
<li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数都必须在它之前声明。</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201001114243391.png" alt="image-20201001114243391"></p>
<ul>
<li>感觉跟数组没什么差别。</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li>数组是相同类型数据的有序集合</li>
<li>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。</li>
<li>其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。</li>
</ul>
<p><strong>数组声明创建</strong></p>
<ul>
<li>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;    <span class="comment">//首选的方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[];    <span class="comment">//效果相同,但不是首选方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java语言使用new操作符来创建数组，语法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure>

<ul>
<li>数组元素是通过下标索引访问的,数组索引从0开始.</li>
<li>通过<code>arrays.length</code>我们可以获取数组长度。</li>
</ul>
<p><strong>三种初始化</strong></p>
<ul>
<li><p>静态初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Man[] mans = &#123;<span class="keyword">new</span> Man(<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">new</span> Man(<span class="number">2</span>,<span class="number">2</span>)&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的默认初始化</p>
<ul>
<li>数组是引用类型,它的元素相当于类的实例变量,因此数组一经分配空间,其中的每个元素页呗按照实例变量同样的方式被隐式初始化。</li>
</ul>
</li>
<li><p>数组的四个基本特点</p>
<ul>
<li>长度是确定的。数组一旦被创建，它的大小就是不可改变的。</li>
<li>数组内元素必须是相同类型，不允许出现混合类型。</li>
<li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li>
<li>数组变量属于引用类型，数组也可以看成对象，数组中的每个元素相当于该对象的成员变量。</li>
<li>数组本身就是对象，Java中对象实在堆中的，因此数组无论保存原始类型还是其他对象类型，<strong>数组对象本身是在堆中的</strong>。</li>
</ul>
</li>
<li><p>多维数组</p>
<ul>
<li><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其中每一个元素都是一个一维数组。</p>
</li>
<li><p>2*5的二维数组定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">5</span>]<span class="comment">//int[][] a也可以</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h4><ul>
<li>数组的工具类java.util.Arrays</li>
<li>虽然数组对象本身并没有什么方法可以供我们调用,但API中提供了一个工具类Arrays供我们使用,从而可以对数据对象进行一些基本的操作。</li>
<li><strong>具体查看JDK帮助文档</strong></li>
<li>Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而“不用”使用对象来调用(注意:是”不用”,而不是”不能”)</li>
<li>常用功能：<ul>
<li>给数组赋值：通过fill方法</li>
<li>对数组排序：通过sort方法，默认升序</li>
<li>比较数组：通过equals方法比较数组中的元素值是否相等。</li>
<li>查找数组元素：通过binarySearch方法能对排好序的数组进行二分查找操作。</li>
</ul>
</li>
</ul>
<h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201001164928462.png" alt="image-20201001164928462"></p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//简单实现下冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">       arr[x] = arr[x]^arr[y];</span><br><span class="line">       arr[y] = arr[x]^arr[y];</span><br><span class="line">       arr[x] = arr[x]^arr[y];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;end-<span class="number">1</span>;x++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[x]&gt;arr[x+<span class="number">1</span>])&#123;</span><br><span class="line">               swap(arr,x,x+<span class="number">1</span>);</span><br><span class="line">               b =<span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> b;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x = arr.length;x&gt;<span class="number">1</span>&amp;&amp;bubble(arr,x);x--);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h4><ul>
<li>当一个数组大部分元素为0,或者为同一值时,可以使用稀疏数组来保存该数组。</li>
<li>稀疏数组的处理方式时：<ul>
<li>记录数组一共有几行几列，有多少个不同值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。</li>
<li>如下图：左边时原始数组，右边是稀疏数族</li>
<li>稀疏数组的第0号元素记录了原始数组的行列以及有效值的个数，其他号元素对应了有效值的行列以及值的大小。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201002105748251.png" alt="image-20201002105748251"></p>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><hr>
<p><strong>Java的核心思想就是OOP</strong></p>
<ul>
<li>面向过程思想<ul>
<li>步骤清晰简单，第一步做什么，第二步做什么…</li>
<li>面向过程适合处理一些较为简单的问题</li>
</ul>
</li>
<li>面向对象思想<ul>
<li>物以类聚，<strong>分类</strong>的思维模式，思考问题首先会解决问题需要哪些类，然后对这些分类进行单独思考。最后才对某个类下的细节进行面向过程的思索。</li>
<li>面向过程适合处理复杂的问题，适合处理需要多人协作的问题！</li>
</ul>
</li>
<li><strong>对于描述复杂的事务，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</strong></li>
</ul>
<h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><ul>
<li>面向对象编程(Object-Oriented Programming,OOP)</li>
<li>面向对象编程的本质就是：以类的方式组织代码，以对象组织（封装）数据。</li>
<li>抽象</li>
<li>三大特性：<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
</li>
<li>从认识论角度考虑是先有对象后有类。对象是具体的事务。类，是对对象的抽象。</li>
<li>从代码运行角度考虑是现有类后有对象。类是对象的模板。</li>
</ul>
<h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4><ul>
<li>类是一种抽象的数据类型,它是对某一类事物的整体描述/定义,但是并不能代表某一个具体的事物.</li>
<li>对象是抽象概念的具体实例。</li>
</ul>
<h4 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h4><ul>
<li>使用<strong>new</strong>关键字创建对象</li>
<li>使用new关键字创建的时候，除了分配内存空间，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。</li>
<li>类种的构造器也称为构造方法，是在进行创建对象的时候必须调用的。并且构造器有以下特点：<ol>
<li>必须和类的名字相同</li>
<li>必须没有返回类型，也不能写void</li>
</ol>
</li>
<li></li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ol>
<li>静态方法和非静态方法：非static的函数可以调用static 的函数,但是static的函数不能够调用非static的函数,因为static的函数是对应类的，跟类一起加载,用类名即可调用，而非static的函数是对应于对象的，当对象new出来之后才能够调用。</li>
</ol>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul>
<li>该露的露，该藏的藏<ul>
<li>我们的程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</li>
</ul>
</li>
<li>封装（数据的隐藏）<ul>
<li>通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。</li>
</ul>
</li>
<li>属性私用，get/set。这样做能够</li>
</ul>
<p><strong>意义</strong></p>
<ol>
<li>提高程序的安全性，保护数据。例如在set方法中我们可以通过一些操作，规避掉一些不合理的数据。</li>
<li>隐藏代码的实现细节。</li>
<li>统一接口。</li>
<li>系统可维护性增加了。</li>
</ol>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>继承的本质是对一批类的抽象，从而实现对现实世界更好的建模。</li>
<li>extends的意思是扩展，子类是父类的扩展。</li>
<li>Java中类只有单继承，没有多继承。一个基类可以有多个派生类，但是一个派生类只能有唯一的一个基类</li>
<li>在Java中所有的类，都默认直接或间接的继承Object类。</li>
<li>继承是类和类之间的一种关系。除此之外，类和类之间还有诸如依赖、组合、聚合等关系。</li>
<li>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示。</li>
<li>子类和父类之间，从意义上讲应具有“is a”的关系</li>
<li>被final修饰的类不可被继承。</li>
</ul>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ol>
<li>super()可以用来调用父类的构造方法，但是必须写在子类构造方法的第一行。</li>
<li>在成员函数中我们也可以用super.method()来调用父类的方法，即使该方法被子类重写了。</li>
<li>super()和this()不能在构造方法中同时调用，因为它们都要求放在方法的第一行。</li>
<li>super类似this，不过它相当于一个可以调用父类属性或方法的权柄（前提是子类有这个访问权限，private的就无法调用）</li>
</ol>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul>
<li><p>重写都是方法的重写,和属性无关。</p>
</li>
<li><p>如果是静态的方法重写，方法的调用只与声明的数据类型有关。例如父类B和父类A中都存在静态的test方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B=&gt;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A=&gt;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">B b = <span class="keyword">new</span> A();</span><br><span class="line">a.test();</span><br><span class="line">b.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    A=&gt;test</span></span><br><span class="line"><span class="comment">    B=&gt;test</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分别调用的是A类和B类的test()方法,并没有多态的出现.如果把static去掉那么都为A=&gt;test.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重写vs重载</p>
<ul>
<li>方法的重载：在同一个类中，出现多个<strong>同名</strong>的方法，<strong>参数列表不同，与返回值类型，修饰符无关</strong></li>
<li>方法的重写：子类中出现和父类一模一样的方法（包括返回值类型，方法名，参数列表，访问权限可以不同，但是子类的重写的方法的访问权限要高于父类）</li>
</ul>
</li>
<li><p>注意事项：</p>
<ol>
<li>重写的方法必须要和父类一模一样（包括返回值类型，方法名，参数列表）</li>
<li>重写的方法可以使用@Override注解来标识</li>
<li>子类中重写的方法的访问权限不能低于父类中方法的访问权限。范围可以扩大,但是不能缩小。</li>
<li><strong>权限修饰符：private&lt;默认(什么都不写)&lt;protected&lt;public,事实上当父类方法为private时,子类对其并不可见,所以根本没有重写这一说,子类可以任意对编写相关同名方法.</strong></li>
<li>抛出的异常：范围与权限修饰符不同，可以被缩小，但不能被扩大。</li>
</ol>
</li>
<li><p>为什么需要重写：</p>
<ol>
<li>父类的功能，子类不一定需要，或者不一定满足。</li>
</ol>
</li>
</ul>
<h4 id="public-gt-protected-gt-default-gt-private"><a href="#public-gt-protected-gt-default-gt-private" class="headerlink" title="public &gt; protected &gt; (default) &gt; private"></a>public &gt; protected &gt; (default) &gt; private</h4><p>上面这四个关键字是Java中的权限修饰符，是实现Java封装特性的重要手段。</p>
<table>
<thead>
<tr>
<th>访问位置\修饰符</th>
<th>public</th>
<th>protected</th>
<th>(default)</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>可</td>
<td>可</td>
<td>可</td>
<td>可</td>
</tr>
<tr>
<td>同一个包</td>
<td>可</td>
<td>可</td>
<td>可</td>
<td>不可</td>
</tr>
<tr>
<td>不同包子类</td>
<td>可</td>
<td>可</td>
<td>不可</td>
<td>不可</td>
</tr>
<tr>
<td>不同包非子类</td>
<td>可</td>
<td>不可</td>
<td>不可</td>
<td>不可</td>
</tr>
</tbody></table>
<p>注意：(default)不是关键字“default”，而是指不写权限修饰符。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul>
<li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li>
<li>注意事项：<ol>
<li>多态是方法的多态，属性没有多态</li>
<li>存在条件：继承关系，方法需要重写，父类的引用指向子类对象。Father f1 = new Son（）；</li>
<li>不可被重写的方法：<ol>
<li>静态方法，属于类，不属于实例</li>
<li>final    常量，不能被更改</li>
<li>private方法    子类不可见</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><ul>
<li>这是一个java的一个操作符，从名字中我们就可以看出它的含义是：…的实例。它的作用便是如此，object instanceof class，可以用来判断这个object是否为该class的一个实例。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">person</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//我们都知道所有类都有一个共同的基类,那就是Object,因此继承关系如下:</span></span><br><span class="line"><span class="comment">//Object&gt;Person&gt;Student;Object&gt;Person&gt;Teacher</span></span><br><span class="line">Object object = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(object instance of Object);</span><br><span class="line">System.out.println(object instance of Person);</span><br><span class="line">System.out.println(object instance of Student);</span><br><span class="line">System.out.println(object instance of Teacher);</span><br><span class="line">System.out.println(object instance of String);</span><br><span class="line"><span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">    ture</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要注意的是,A instanceof B,编译的时候会看A的引用类型与B是否有关系,如果没关系那么直接报错,如果有关系,运行的时候,会根据A的实际类型,即其指向的对象的类型来判断A是否为B的一个实例,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//改成</span></span><br><span class="line">Student object = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//则下面语句会直接报错.</span></span><br><span class="line">System.out.println(object <span class="keyword">instanceof</span> Teacher);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译看左(引用类型),运行看右(对象类型),这点同样适用于多态,方法的调用,在编译期间看引用类型是否有这个方法,而运行期间实际调用取决于对象类型.</p>
</li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//代码块(匿名代码块),跟对象一起加载,在构造器之前执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//静态代码块,跟类一起加载,只执行一次，可以用来赋初值，但要注意的是它与类一起加载，因此它赋值的变量必须也是静态的，且该操作只会执行一次，切记。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="number">1.</span>&#123;&#125;</span><br><span class="line">        <span class="number">2.</span>&#123;<span class="keyword">new</span> Person();&#125;</span><br><span class="line">        <span class="number">3.</span>&#123;<span class="keyword">new</span> Person();<span class="keyword">new</span> Person();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    1.    静态代码块</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    2.    静态代码块    </span></span><br><span class="line"><span class="comment">        匿名代码块</span></span><br><span class="line"><span class="comment">        构造方法</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    3.    静态代码块</span></span><br><span class="line"><span class="comment">        匿名代码块</span></span><br><span class="line"><span class="comment">        构造方法</span></span><br><span class="line"><span class="comment">        匿名代码块</span></span><br><span class="line"><span class="comment">        构造方法</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment"> 1. 1情况下main方法为空语句,但依旧输出了&quot;静态代码块&quot;,且后面两种情况下都只出现一次静态代码块,由此可见静态代码块在类加载时期执行.且只执行一次</span></span><br><span class="line"><span class="comment"> 2. 根据2,3可以看出匿名代码块在构造方法之前执行,不是因为它写在构造方法之上,调换位置之后运行结果不变.且每次生成对象是都会调用该匿名代码块,因此它跟对象一起加载.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>static修饰的东西，无论是变量，函数亦或是代码块，或者内部类，都会变的与类挂钩，随类一起加载，可以由类名直接调用，切记，所有的对象实例都共享这些静态成员。</li>
<li>静态导入包：import static java.lang.Math.random;这样做可以将包中的一些方法，或者参数导入进来，可以不在通过类名调用。</li>
<li>注意不要把c++中的static代入进来，c++中static主要起一个隐藏的作用，而java中static表示成员与类挂钩。</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li><p><strong>abstract</strong>修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是<strong>抽象方法</strong>；如果修饰类，那么该类就是<strong>抽象类</strong>。</p>
</li>
<li><p><strong>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类</strong>。</p>
</li>
<li><p>抽象类,不能实例化对象,但是可以声明变量,用来关联它的子类。</p>
</li>
<li><p>抽象方法不能有方法体，只有声明，没有方法的实现，它是用来让子类实现的。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">([参数])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类继承抽象类,那么就必须实现抽象类没有实现的抽象方法,否则该子类也要声明为抽象类。</p>
</li>
<li><p>尽管抽象类不能实例化，但他依旧存在构造方法，该抽象方法仅用实例化子类是调用，本身不能用来实例化抽象类。</p>
</li>
<li><p>abstract不能与以下关键字共存：</p>
<ol>
<li>private    冲突 – 对子类隐藏,而 abstract 必须让子类</li>
<li>2.重写  final      冲突 – 不能被重写,矛盾  </li>
<li>static     无意义– 类名调用,没有方法体,无意义</li>
</ol>
</li>
<li><p><strong>为什么允许一个没有抽象方法的类可以是抽象类呢？</strong></p>
<p>因为我们要使得某些类不能被用来实例化,只能用来作为模板继承它本身,而这要求它是抽象的,但是有时候我们只想要实现该模板的某些功能，因为不知道每次使用的时候需要实现哪部分功能，因此这样的类通常定义了一组方法体为空的方法。</p>
<p>就以适配器类来说吧MouseAdapter是抽象类，但是没有抽象方法，<br>（如果他不是抽象的）直接实例化这个类没有没有任何意义，<br>既然我们需要使用这个类，就必然会覆盖某个方法，但又不知道是哪个方法，为了不让子类去重复实现一些他们不需要的方法，所以通常这种抽象类会将定义一系列方法体为空的方法。<br>使用者根据需要来覆盖方法，<br>一个没有抽象方法的抽象类一般来讲都会有诺干空的方法，这些方法不是必须要实现的，但是如果都不去实现这些方法，那这个类就没有什么意义了。</p>
</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范（抽象方法）都有</li>
<li>接口：只有规范！自己无法写法，专业的约束！约束和实现分离：面向接口编程。</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。例如：如果你是汽车，则必须能跑；如果你是学生，则必须会念书；</li>
<li>接口的本质是契约，就像我们人间的法律一样。制定好以后，大家都遵守。</li>
<li>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、java、c#等），就是因为设计模式所研究的，实际上就是如何合理的去抽象。声明类的关键字是class，声明接口的关键字是interface。</li>
<li>类中成员变量默认是包内可见，而接口中属性默认是public  static final的，方法默认是public abstract的，且只能是这样的，不可修改。</li>
<li>与类不同，接口允许多继承。</li>
<li>要注意的是extends必须写在implements的前面</li>
<li>接口可以继承多个接口.</li>
</ul>
<h4 id="接口VS抽象类"><a href="#接口VS抽象类" class="headerlink" title="接口VS抽象类"></a>接口VS抽象类</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/1064302-20161230090438195-1243745647.png" alt="img"></p>
<p><strong>什么时候使用抽象类和接口</strong></p>
<ul>
<li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li>
<li>如果你想实现多重继承，那么你必须使用接口。由于<strong>Java不支持多继承</strong>，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<h4 id="契约设计"><a href="#契约设计" class="headerlink" title="契约设计"></a>契约设计</h4><p>契约设计：类不会直接使用另外一个类，而是采用接口形式，外部可以“空投”任意实现了该接口的类。</p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ul>
<li></li>
<li>类别：<ol>
<li>成员内部类<ul>
<li>在类的内部定义,与实例变量、实例方法同级别的类。</li>
<li>外部类的一个实例部份，创建内部类对象时，必须依赖外部类对象。</li>
<li>成员内部类中不能定义静态成员，因为他的创建依赖于外部类对象，但是可以包含静态常量。</li>
</ul>
</li>
<li>静态内部类<ul>
<li>直接调用静态内部类，外部类不会加载。</li>
</ul>
</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ol>
</li>
<li>内部类和外部类的联系：</li>
</ul>
<ol>
<li><p><strong>内部类就是在一个类的内部再定义一个完整的类</strong>，比如，A类中定义一个B类，那么B类相对于A类来说就称为内部类，而A类相对于B类来说就是外部类了。</p>
</li>
<li><p>内部类对象的创建需要接助外部类对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Inner为Outer中的内部类</span></span><br><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line"><span class="comment">//内部类的对象需要由外部类的对象来new.</span></span><br><span class="line">Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类可以使用外部类的任何变量和方法，但是外部类必须要实例化内部类才可以使用内部类。<br>而且在实例化之前必须先创建一个外部类的实例。</p>
</li>
<li><p>如果内部类跟外部类出现了重名现象：</p>
<ul>
<li>内部类使用内部类的成员变量格式是: this.内部类成员变量名。</li>
<li>内部类使用外部类的成员变量格式是: 外部类名称.this.外部类成员变量名。</li>
<li>如果不显示表明，若在内部类中访问同名变量，则优先访问内部类中的变量。</li>
</ul>
</li>
<li><p><strong>外部类</strong>的访问权限只有两种：<strong>public和(default)。</strong><br>但是内部类因类型不同所以对应的访问权限也不一样。</p>
</li>
<li><p>编译之后内部类也会生成独立的字节码文件(Outer$Inner.class),上述四种内部类都会有。</p>
</li>
<li><p>内部类（不论是静态内部类还是非静态内部类）都是在第一次使用时才会被加载。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类方法&quot;</span>);</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匿名内部类,UserService是一个接口,</span></span><br><span class="line">        UserService us = <span class="keyword">new</span> UserService()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//内部类的对象需要由外部类的对象来new.</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常机制-Exception"><a href="#异常机制-Exception" class="headerlink" title="异常机制(Exception)"></a>异常机制(Exception)</h4><ul>
<li><p>Java 中的异常（Exception）又称为例外，是一个在程序执行期间发生的事件，它中断正在执行的程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类。</p>
</li>
<li><p>异常发生在程序运行期间，它影响了正常的程序执行流程。</p>
</li>
<li><p>要理解Java异常处理是如何工作的，需要掌握以下三种类型的异常：</p>
<ol>
<li>检查性异常（非运行时异常）：最具代表的检查性异常时用户错误操作引起的异常，这是程序员无法预见的。例如要打开一个不存在的文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略，必须做好相应的捕获处理。</li>
<li>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li>错误Error：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译时是检查不到的。</li>
</ol>
</li>
</ul>
<h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201011170335084.png" alt="image-20201011170335084"></p>
<p>上图只显示一些常见的异常。</p>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><ul>
<li>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</li>
<li>Java虚拟机运行错误（Virtural MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现<strong>OutOfMemoryError</strong>。这些异常发生时，Java虚拟机，一般会选择线程终止。</li>
<li>Error还可能发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外。</li>
</ul>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><ul>
<li>在Exception分支中有一个重要的子类：<strong>RuntimeException（运行时异常）</strong><ul>
<li>ArrayIndexOutOfBoundsException(数组下标越界)</li>
<li>NullPointerException(空指针异常)</li>
<li>ArithmeticException(算数异常)</li>
<li>MissingResourceException(丢失资源)</li>
<li>ClassNotFoundException(找不到类)等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。</li>
</ul>
</li>
<li>这些异常一般是由程序逻辑错误引起的，程序员应该从逻辑角度尽可能避免这类异常的发生。</li>
<li>Error和Exception的区别：Error通常是灾难性的致命性的错误，是程序无法控制和处理的，当出现这些异常时，JVM一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</li>
</ul>
<h4 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h4><ul>
<li>抛出异常</li>
<li>捕获异常</li>
<li>异常处理的五个关键字：try、catch、finally、throw、throws</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExpt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//try监控区域</span></span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;<span class="comment">//catch 捕获异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;devided by zero&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//可以捕获多个异常,范围较大的异常放在下头,因为一旦捕获了异常就不会在判断其他的catch了,所以为了让异常捕获更有针对性,所以当两个异常有继承关系的时候,更高级别的异常应该放到较后的顺序进行捕获. </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;<span class="comment">//处理善后工作,例如关闭IO资源等.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;一定会走&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以通过throw和throws来抛出异常,在方法中我们通过throw关键字主动抛出异常,也可以在方法头部通过throws关键字表示该方法处理不了某异常,可能会抛出某异常.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExpt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> TestExpt().test(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    haha</span></span><br><span class="line"><span class="comment">    处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可见当我们用throw关键字主动抛出异常时候,方法会立即结束.</strong></li>
</ul>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><ul>
<li>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需要继承Exception类即可。</li>
<li>在程序中使用自定义异常类，大体可分为以下几个步骤：<ol>
<li>创建自定义异常类。</li>
<li>在方法中通过throw关键字抛出异常对象。</li>
<li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li>
<li>在出现异常方法的调用者处捕获并处理异常。 </li>
</ol>
</li>
</ul>
<h4 id="实际应用中的经验总结"><a href="#实际应用中的经验总结" class="headerlink" title="实际应用中的经验总结"></a>实际应用中的经验总结</h4><ul>
<li>处理运行时异常时，采用逻辑去合理规避，同时辅以try-catch处理。</li>
<li>在多重catch块后面，可以加一个catch(Exception)来处理可能会被遗漏的异常。</li>
<li>对于不确定的代码，也可以加上try-catch，用来处理潜在的异常。</li>
<li>尽量去处理异常，切忌只是简单地调用printStackTrace()来打印异常信息。</li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定。</li>
<li>尽量添加finally语句块去释放占用的资源。</li>
</ul>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><hr>
<h4 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h4><ul>
<li>hashcode()</li>
<li>toString()</li>
<li>clone()</li>
<li>getClass()</li>
<li>notify()</li>
<li>wait()</li>
<li>equals()</li>
</ul>
<h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><ul>
<li>常见的数学运算</li>
</ul>
<h4 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h4><ul>
<li>生成随机数    UUID</li>
</ul>
<h4 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h4><ul>
<li>创建文件</li>
<li>查看文件</li>
<li>修改文件</li>
<li>删除文件</li>
</ul>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>自动装箱和拆箱.</p>
<h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><ul>
<li>Date</li>
<li>SimpleDateFormat  yyyy-mm-dd HH:MM:SS</li>
<li>Calendar(建议使用)</li>
</ul>
<h4 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h4><ul>
<li>不可变性 final</li>
<li>适用于操作量较少的情况</li>
</ul>
<h4 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h4><ul>
<li>可变长    append()</li>
<li>适用于多线程数据量较大的情况</li>
<li>效率低但安全</li>
</ul>
<h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><ul>
<li>可变长</li>
<li>适用于单线程数据量较大</li>
<li>效率高,不安全</li>
</ul>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><hr>
<h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><ul>
<li><p>Collection</p>
<ul>
<li>List(有序可重复)<ul>
<li>ArrayList </li>
<li>LinkedList</li>
<li>Vector</li>
<li>Stack </li>
</ul>
</li>
<li>Set(无需不可重复)<ul>
<li>HashSet</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li>HashMap</li>
<li>TreeMap</li>
</ul>
</li>
<li><p>Collections工具类</p>
</li>
<li><p>泛型&lt;&gt;约束,避免类型转换之间的问题</p>
</li>
<li><p>子主题</p>
</li>
</ul>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul>
<li>add</li>
<li>remove</li>
<li>contains</li>
<li>size  </li>
</ul>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>getFirst()</li>
<li>getLast()</li>
<li>removeFirst()</li>
<li>addFirst()</li>
</ul>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><h4 id="HashMap-重点"><a href="#HashMap-重点" class="headerlink" title="HashMap(重点)"></a>HashMap(重点)</h4><p>JDK1.7：数组+链表</p>
<p>JDK1.8：hash表 = 数组+链表+红黑树</p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><hr>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><hr>
<ul>
<li>程序：程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。</li>
<li>进程：是程序的一次执行过程，是一个动态的概念。是系统分配资源的最小单位。</li>
<li>线程：通常在一个进程中可以包含若干个线程，当然一个进程至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的基本单位。</li>
<li>注意：很多多线程是模拟出来的，真正的多线程是指由多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，只是因为切换的速度很快，所以就产生了同时执行的错觉。</li>
<li>对同一份资源操作时，会存在资源抢夺问题，需要加入并发控制。</li>
<li>线程会带来额外的开销，如CPU调度时间，并发控制开销。</li>
</ul>
<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201012155703227.png" alt="image-20201012155703227"></p>
<h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><ul>
<li>自定义线程类继承Thread类</li>
<li>重写run()方法，编写线程执行体。</li>
<li>创建线程对象，调用start()方法启动线程。</li>
<li>线程不一定立即执行，这取决于操作系统的CPU调度 </li>
</ul>
<h4 id="案例：下载图片"><a href="#案例：下载图片" class="headerlink" title="案例：下载图片"></a>案例：下载图片</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Thread;</span><br><span class="line"><span class="comment">//导了一个apache的jar包</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String URL;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebDownloader</span><span class="params">(String URL,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.URL = URL;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Downloader downloader = <span class="keyword">new</span> Downloader();</span><br><span class="line">        downloader.download(URL,name);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载完成: &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WebDownloader webDownloader1 = <span class="keyword">new</span> WebDownloader(URL1, <span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        WebDownloader webDownloader3 = <span class="keyword">new</span> WebDownloader(URL2, <span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line">        WebDownloader webDownloader2 = <span class="keyword">new</span> WebDownloader(URL3, <span class="string">&quot;3.jpg&quot;</span>);</span><br><span class="line">        webDownloader3.start();</span><br><span class="line">        webDownloader2.start();</span><br><span class="line">        webDownloader1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downloader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String URL,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(URL),<span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;IO异常: Downloader|&quot;</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><ul>
<li>定义MyRunnable实现Runnable接口</li>
<li>实现run()方法,编写线程执行体</li>
<li>创建线程对象,调用start()方法启动线程.</li>
<li>大多数情况下，如果只想重写 <code>run()</code> 方法，而不重写其他 <code>Thread</code> 方法，那么应使用 <code>Runnable</code> 接口。这很重要，因为除非程序员打算修改或增强类的基本行为，否则不应为该类创建子类。</li>
</ul>
<p><strong>建议实现Runnable接口,可避免单继承局限性,灵活方便,且方便同一个对象被多个线程使用,即一份资源,多个代理.</strong></p>
<h4 id="初识并发问题"><a href="#初识并发问题" class="headerlink" title="初识并发问题"></a>初识并发问题</h4><p>上面提到了实现Runnable接口之后,能够让同一个对象被多个线程使用,由于资源只有一份,所以多个线程同时操作的情况下,容易出现线程不安全,数据紊乱的情况,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lhf_siven.demo.TestExpt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;拿到了第&quot;</span>+num--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread1 testThread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        <span class="keyword">new</span> Thread(testThread1,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testThread1,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testThread1,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    A拿到了第10张票</span></span><br><span class="line"><span class="comment">    C拿到了第9张票</span></span><br><span class="line"><span class="comment">    B拿到了第10张票</span></span><br><span class="line"><span class="comment">    C拿到了第8张票</span></span><br><span class="line"><span class="comment">    A拿到了第7张票</span></span><br><span class="line"><span class="comment">    B拿到了第8张票</span></span><br><span class="line"><span class="comment">    C拿到了第6张票</span></span><br><span class="line"><span class="comment">    B拿到了第5张票</span></span><br><span class="line"><span class="comment">    A拿到了第4张票</span></span><br><span class="line"><span class="comment">    C拿到了第3张票</span></span><br><span class="line"><span class="comment">    A拿到了第2张票</span></span><br><span class="line"><span class="comment">    B拿到了第1张票</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上面这串代码我们模拟了三个线程同时抢票的过程,三个线程共享一个TestThread对象,从输出中我们可以发现,有某些票同时被几个线程所持有,这显然不是我们想要的,一张票理应只能由一个线程所持有。要想解决这一点就得用到线程同步。</p>
<h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">//可返回结果并且可能抛出异常的任务。实现者定义了一个不带任何参数的叫做 <span class="title">call</span> 的方法。<span class="title">Callable</span> 接口类似于 <span class="title">Runnable</span>，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 <span class="title">Runnable</span> 不会返回结果，并且无法抛出经过检查的异常。</span></span><br><span class="line">//注意:V不能是基本类型,必须是Object,如果实在要返回基本类型,那可以改成对应的包装类.</span><br></pre></td></tr></table></figure>



<ol>
<li>实现Callable接口,需要返回值类型</li>
<li>重写call方法,可以抛出异常</li>
<li>创建目标对象</li>
<li>创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);</li>
<li>提交执行：Future<Boolean> result1 = ser.submit(t1);</Boolean></li>
<li>获取结果：boolean r1 = result1.get()</li>
<li>关闭服务：ser.shutdownNow();</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把之前的下载图片,改成了用Callable的做法.</span></span><br><span class="line"><span class="keyword">package</span> com.lhf_siven.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Downloader downloader = <span class="keyword">new</span> Downloader();</span><br><span class="line">        downloader.download(url,name);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载完成: &quot;</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable(URL1);</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable(URL2);</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable(URL3);</span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        Future&lt;Boolean&gt; r1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; r2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; r3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        ser.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downloader1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String URL,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(URL),<span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;IO异常: Downloader|&quot;</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h4><ul>
<li>真实对象和代理对象都要实现同一个接口</li>
<li>代理角色要代理真实角色</li>
</ul>
<p>好处：</p>
<ul>
<li>代理对象可以做很多真实对象做不了的事情</li>
<li>真实对象可以专注做自己的事情。</li>
</ul>
<p>运用到了接口的解耦性。</p>
<p>在多线程中我们运用代理模式，因为Thread实现了Runnable接口，我们只要写一个实现了Runnable接口的匿名类即可,我们只要关注run方法该如何实现,而Thread为我们提供了很多别的帮助。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;    ... &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">           </span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;haha&quot;</span>));还有这种写法</span><br></pre></td></tr></table></figure>

<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><ul>
<li><p>λ是希腊字母表中排序第是一位的字母,英语名称为Lambda</p>
</li>
<li><p>其实质数于函数式编程的概念</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(params) -&gt; expression[表达式]</span></span><br><span class="line"><span class="comment">(params) -&gt; statement[语句]</span></span><br><span class="line"><span class="comment">(params) -&gt; &#123;statements&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line">a -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>+a);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在多线程编程时我们就可以运用Lambda表达式,而减少匿名内部类的定义,格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;statements&#125;).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么要使用lambda表达式</p>
<ul>
<li>避免匿名内部类定义过多</li>
<li>可以让你的代码看起来很简洁</li>
<li>去掉了一堆不太关键的逻辑</li>
</ul>
</li>
<li><p>理解Functional Interface(<strong>函数式接口</strong>)式学习Java8 lambda表达式的关键所在</p>
</li>
<li><p>函数式接口的定义:</p>
<ul>
<li>任何接口,如果指包含<strong>唯一一个抽象方法</strong>,那么它就是一个函数式接口。</li>
<li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象，也就是说上面()-&gt;{}就等价于实现了一个接口并创建了相应的对象,因此把它赋值给对应的接口变量,例如Demo demo = ()-&gt;{};这个语句就是把一个Demo接口实现,创建了相应对象并赋值给了demo变量.。 </li>
<li>注意lambdea只能用于函数时接口,而不能用于只有一个抽象方法的抽象类。</li>
<li>如果某函数式接口</li>
</ul>
</li>
</ul>
<h4 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201022105815867.png" alt="image-20201022105815867"></p>
<h4 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h4><ul>
<li>不推荐使用JDK提供的stop()、destroy()方法。【已废弃】</li>
<li>推荐让线程自己停止下来</li>
<li>建议使用一个标志位进行终止变量，例若flag=false，终止线程运行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在主线程控制标志位flag,决定子线程是否停止.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> judge = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(judge) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run...Thread&quot;</span> + i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.judge = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadStop threadStop = <span class="keyword">new</span> ThreadStop();</span><br><span class="line">        <span class="keyword">new</span> Thread(threadStop).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5000000</span>) &#123;</span><br><span class="line">                threadStop.stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程停止======&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="线程休眠（Sleep）"><a href="#线程休眠（Sleep）" class="headerlink" title="线程休眠（Sleep）"></a>线程休眠（Sleep）</h4><ul>
<li>sleep(时间):指定当前线程阻塞的<strong>毫秒数</strong>;</li>
<li>sleep存在异常InterruptedException;</li>
<li>sllep时间达到后线程进入<strong>就绪状态</strong>;</li>
<li>sleep可以用来模拟网络延迟,倒计时等,如下。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date Startdate = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(Startdate));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Startdate = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>每一个对象都有一个锁，sleep不会释放锁；</strong></li>
</ul>
<h4 id="线程礼让（Yield）"><a href="#线程礼让（Yield）" class="headerlink" title="线程礼让（Yield）"></a>线程礼让（Yield）</h4><ul>
<li>礼让线程,让当前正在执行的线程暂停,但不阻塞</li>
<li>将线程从运行状态转为就绪状态</li>
<li><strong>让cpu重新调度,礼让不一定成功!由cpu决定。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;A-&gt;Start&quot;</span>);</span><br><span class="line">    Thread.yield();</span><br><span class="line">    System.out.println(<span class="string">&quot;A-&gt;End&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;B-&gt;Start&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;B-&gt;End&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h4 id="线程强制执行（Join）"><a href="#线程强制执行（Join）" class="headerlink" title="线程强制执行（Join）"></a>线程强制执行（Join）</h4><ul>
<li><strong>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程转为阻塞</strong>。</li>
<li>可以简单将Join理解为插队。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不插队多半Main跑完A才跑,但是有了join,可以保证Main执行到50的时候,执行A,知道A线程执行完,主线程才继续执行.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo(),<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Main-&gt;&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">50</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;A========&quot;</span>);</span><br><span class="line">                t1.start();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h4><ul>
<li><p>Thread.State</p>
<p>线程可以处于以下状态之一：</p>
<ul>
<li>NEW：尚未启动的线程处于此状态。</li>
<li>RUNNABLE：在Java虚拟机中执行的线程处于此状态。</li>
<li>BLOCKED：被阻塞等待监视器锁定的线程处于此状态</li>
<li>WAITING：正在等待另一个线程执行特定动作的线程处于此状态。</li>
<li>TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</li>
<li>TERMINATED：已退出的线程处于此状态</li>
</ul>
<p><strong>一个线程可以在给定时间点处于某一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) </span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line">        thread.start();</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        <span class="keyword">while</span>(state != Thread.State.TERMINATED)&#123;</span><br><span class="line">            System.out.println(state);</span><br><span class="line">            state = thread.getState();</span><br><span class="line">            <span class="keyword">try</span> &#123; thread.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(state);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">        NEW</span></span><br><span class="line"><span class="comment">        RUNNABLE</span></span><br><span class="line"><span class="comment">        RUNNABLE</span></span><br><span class="line"><span class="comment">        TIMED_WAITING</span></span><br><span class="line"><span class="comment">        TERMINATED</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程,线程调度器按照优先级决定应该调度哪个线程来执行。</p>
</li>
<li><p>线程的优先级用数字表示，范围1~10。</p>
<ul>
<li>Thread.MIN_PRIORITY = 1;</li>
<li>Thread.MAX_PRIORITY = 10;</li>
<li>Thread.NORM_PRIORITY = 5;（默认）</li>
</ul>
</li>
<li><p>使用以下方式改变或获取优先级</p>
<p>getPriority()    setPriority(int)</p>
</li>
<li><p>优先级低只是意味着获得调度的概率低，但并不意味着优先级低的就一定是最后被调用，由cpu决定。</p>
</li>
<li><p>优先级的设定建议在start()调度前。</p>
</li>
</ul>
<h4 id="守护-daemon-线程"><a href="#守护-daemon-线程" class="headerlink" title="守护(daemon)线程"></a>守护(daemon)线程</h4><ul>
<li>线程分为用户线程和守护线程</li>
<li>虚拟机必须确保用户线程执行完毕</li>
<li>如：后台记录操作日志、内存监控、垃圾回收等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        You you = <span class="keyword">new</span> You();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        thread1.setDaemon(<span class="keyword">true</span>);<span class="comment">//默认false,表示是用户进程,正常的进程都是用户进程!</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(you).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上帝保佑着你=====&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你一生都开心的活着======&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;GoodBye=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果不将上帝线程设置为守护线程,那么这个程序会一直循环的跑下去知道程序崩溃,因为虚拟机要确保用户线程执行完毕,而一旦我们将其设置为守护线程,那么虚拟机是不会去管他是否执行完毕的,当所有用户线程执行完毕之后,虚拟机就会结束执行,守护线程也会随着结束。</strong></p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul>
<li><p>现实生活中，我们会遇到“同一个资源，多个人都想使用”的问题，例如：食堂排队打饭，每个人都想吃饭，最天然的解决办法就是—排队，一个个来。</p>
</li>
<li><p>处理多线程问题是，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的<strong>等待池</strong>形成队列，等待前面线程使用完毕，下一个线程再使用。</p>
</li>
<li><p><strong>线程同步形成条件：队列+锁</strong></p>
</li>
<li><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确行，java在访问时加入了<strong>锁机制synchronized</strong>，当一个线程获得对象的排它锁，则独占资源，其他线程必须等待。存在以下问题：</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起；</li>
<li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。  </li>
</ul>
</li>
</ul>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><hr>
<h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><hr>
<h3 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h3><hr>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li><p>Annotation是从JDK5.0开始引入的新技术。</p>
</li>
<li><p>Annotation的作用：</p>
<ul>
<li>不是程序本身，可以对程序做出解释（这一点与注释（commment）没什么区别）</li>
<li><strong>可以被其他程序（例如：编译器）读取。</strong></li>
</ul>
</li>
<li><p>Annotation的格式：</p>
<ul>
<li>注解是以**@注释名**在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings（value = “unchecked”）</li>
</ul>
</li>
<li><p>Annotation在哪里使用？</p>
<ul>
<li>可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。</li>
</ul>
</li>
</ul>
<h4 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h4><ul>
<li>@Override：定义在java.langOverride中,此注释只适用于修辞方法,表示一个方法声明打算重写超类中的另一个方法声明。</li>
<li>@Deprecated：定义在java.lang.Deprecated中,此注释可以用于修饰方法,属性,类,表示不鼓励程序员使用这样的元素,通常是因为它很危险或者存在更好的选择。</li>
<li>@SuppressWarnings(镇压警告)：定义在java.lang.SuppressWarnings中,用来抑制编译时的警告信息。<strong>与前面两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性地使用就好了。</strong><ul>
<li>@SuppressWarnings（“all”）</li>
<li>@SuppressWarnings（“unchecked”）</li>
<li>@SuppressWarnings（value={“unchecked”，”deprecation“}）</li>
<li>等等…</li>
</ul>
</li>
</ul>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul>
<li>元注解的作用就是负责注解其他注解，Java定义了4个标准的mata-annotation类型，他们被用来提供对其他annotation类型作说明。</li>
<li>这些类型和他们所支持的类在java.lang.annotation包中可以找到。（@Target，@Retention，@Documented，@Inherited）<ul>
<li>@Target：用于描述注解的适用范围（即：被描述的注解可以用在什么地方）</li>
<li>@Retention：表示需要在什么级别保存该注释 信息，用于描述注解的生命周期（SOURCE&lt;CLASS&lt;<strong>RUNTIME</strong>）</li>
<li>@Document：说明该注解将被包含在javadoc中</li>
<li>@Inherited：说明子类可以继承父类中的该注解。</li>
</ul>
</li>
</ul>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><ul>
<li>使用@interface自定义注解时，自动挤成了java.lang.annotation.Annotation接口</li>
<li>分析：<ul>
<li>@interface用来声明一个注解，格式：<code>[public] @interface 注解名&#123;定义内容&#125;</code></li>
<li>其中的每一个方法实际上是声明了一个配置参数。</li>
<li>方法的名称就是参数的名称。</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型：Class、String、enum）。</li>
<li>可以通过default来声明参数的默认值。</li>
<li>如果只要一个参数成员，一般参数名为value,这样在赋实参的时候可以省略<code>value = </code>。</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串、0做默认值。 </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="comment">//注解的参数:参数类型 + 参数名();</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    String[] school()<span class="keyword">default</span> <span class="string">&quot;山东大学&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反射（Reflection）"><a href="#反射（Reflection）" class="headerlink" title="反射（Reflection）"></a>反射（Reflection）</h3><hr>
<h4 id="静态VS动态用语言"><a href="#静态VS动态用语言" class="headerlink" title="静态VS动态用语言"></a>静态VS动态用语言</h4><p><strong>动态语言</strong></p>
<ul>
<li><p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p>
</li>
<li><p>主要的动态语言：Object-C、C#、JavcScript、PHP、Python等。</p>
</li>
</ul>
<p><strong>静态语言</strong></p>
<ul>
<li>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</li>
<li>Java不是动态语言，但是Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让程序员编程的时候可以更加灵活！</li>
</ul>
<h4 id="Java-Reflection"><a href="#Java-Reflection" class="headerlink" title="Java Reflection"></a>Java Reflection</h4><ul>
<li><p>Reflection(反射)是Java被视为准动态语言的关键,反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息,并能直接操作任意对象的内部属性及方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载完类之后,在堆内存的方法区中就产生了一个Class类型的对象(<strong>一个类只有一个Class对象，一个类被加载后，类的整个结构都会被封装在Class对象中。</strong>)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子能够看到类的结构，所以，我们形象的称之为：反射。</p>
</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201209204252185.png" alt="image-20201209204252185"></p>
<h4 id="Java反射机制提供的功能"><a href="#Java反射机制提供的功能" class="headerlink" title="Java反射机制提供的功能"></a>Java反射机制提供的功能</h4><ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任何一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
<li>…… </li>
</ul>
<h4 id="Java反射的优点和缺点"><a href="#Java反射的优点和缺点" class="headerlink" title="Java反射的优点和缺点"></a>Java反射的优点和缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>可以实现动态创建对象和编译，体现出很大的灵活性。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且要求它满足我们的请求。这类操作总是慢于直接执行相同的操作。</li>
</ul>
<h4 id="反射相关的主要API"><a href="#反射相关的主要API" class="headerlink" title="反射相关的主要API"></a>反射相关的主要API</h4><ul>
<li><p>java.lang.Class：代表一个类</p>
</li>
<li><p>java.lang.reflect.Method：代表类的方法</p>
</li>
<li><p>java.lang.reflect.Field：代表类的成员变量</p>
</li>
<li><p>java.lang.reflect.Constructor：代表类的构造器</p>
</li>
<li><p>……</p>
</li>
</ul>
<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201209231444884.png" alt="image-20201209231444884"></p>
<p>在Object类中定义了以下的方法，此方法将被所有子类继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title">getClass</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上的方法返回值的类型是一个Class类,此类是Java反射的源头,实际上所谓反射从程序的运行结果来看也很好理解,即：可以通过对象反射求出类的名称。</li>
</ul>
<h5 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象?"></a>哪些类型可以有Class对象?</h5><ul>
<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组(从下面的例子可以看出,无论数组多长,一种类型的数组只对应一个Class对象)</li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class c1 = Object.class;    //类</span><br><span class="line">    Class c2 = Comparable.class;//接口</span><br><span class="line">    Class c3 = String[].class;  //一维数组</span><br><span class="line">    Class c4 = <span class="keyword">int</span> [][].class;  //二维数组</span><br><span class="line">    Class c5 = Override.class;  //注解</span><br><span class="line">    Class c6 = ElementType.class;//枚举</span><br><span class="line">    Class c7 = <span class="keyword">void</span>.class;      //<span class="keyword">void</span></span><br><span class="line">    Class c8 = <span class="keyword">int</span>.class;       //基本数据类型</span><br><span class="line">    Class c9 = Integer.class;   //包装器类</span><br><span class="line">    Class c10 = Class.class;    //Class</span><br><span class="line">    System.out.println(c1);</span><br><span class="line">    System.out.println(c2);</span><br><span class="line">    System.out.println(c3);</span><br><span class="line">    System.out.println(c4);</span><br><span class="line">    System.out.println(c5);</span><br><span class="line">    System.out.println(c6);</span><br><span class="line">    System.out.println(c7);</span><br><span class="line">    System.out.println(c8);</span><br><span class="line">    System.out.println(c9);</span><br><span class="line">    System.out.println(c10);</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    System.out.println(a.getClass().hashCode());</span><br><span class="line">    System.out.println(b.getClass().hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">    class java.lang.Object</span></span><br><span class="line"><span class="comment">    interface java.lang.Comparable</span></span><br><span class="line"><span class="comment">    class [Ljava.lang.String;</span></span><br><span class="line"><span class="comment">    class [[I</span></span><br><span class="line"><span class="comment">    interface java.lang.Override</span></span><br><span class="line"><span class="comment">    class java.lang.annotation.ElementType</span></span><br><span class="line"><span class="comment">    void</span></span><br><span class="line"><span class="comment">    int</span></span><br><span class="line"><span class="comment">    class java.lang.Integer</span></span><br><span class="line"><span class="comment">    class java.lang.Class</span></span><br><span class="line"><span class="comment">    356573597</span></span><br><span class="line"><span class="comment">    356573597</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>只要元素类型与维度一样(例:一维数组跟二维数组对应的是两个不同的Class),就是同一个Class对象</strong>\</p>
<h4 id="类加载内存分析"><a href="#类加载内存分析" class="headerlink" title="类加载内存分析"></a>类加载内存分析</h4><h5 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h5><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201210223238882.png" alt="image-20201210223238882"></p>
<h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p>当程序主动使用某个类时,如果该类还未被加载到内存中,则系统会通过如下三个步骤来对该类进行初始化.</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201211201854550.png" alt="image-20201211201854550"></p>
<h4 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h4><ul>
<li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象。</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul>
</li>
<li>初始化：<ul>
<li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中<strong>所有类变量的赋值动作和静态代码块中的语句合并产生的（执行顺序为代码的先后顺序），因此这两部分内容在程序的运行周期中只会运行一次</strong>。（类构造器是构造类信息的，不是构造该类对象的构造器)</clinit></clinit></li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</clinit></li>
</ul>
</li>
</ul>
<h4 id="什么时候会发生类初始化？"><a href="#什么时候会发生类初始化？" class="headerlink" title="什么时候会发生类初始化？"></a>什么时候会发生类初始化？</h4><ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，若其父类没有被初始化，则先会初始化它的父类</li>
</ul>
</li>
<li>类的被动引用（不会发生类的初始化）<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化。</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（因为常量在链接阶段就存入调用类的常量池中了，所以说加载-链接-初始化并不一定是三个过程都要完成）</li>
</ul>
</li>
<li>如果只是单单声明了变量，并不会引发类的加载。</li>
</ul>
<h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><ul>
<li><p>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。JVM规范定义了如下类型的加载器：</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201212205748029.png" alt="image-20201212205748029"><br>核心库是jre里头的rt.jar(rt=runtime)</p>
</li>
<li><p>类缓存：标准的JavaSE类加载器可以按要求查找类，但<strong>一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</strong>。</p>
</li>
</ul>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201212205519171.png" alt="image-20201212205519171"></p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201212221259163.png" alt="image-20201212221259163"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取系统类加载器</span></span><br><span class="line">    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader);</span><br><span class="line">    <span class="comment">//获取系统类加载器的父类加载器---&gt;扩展类加载器</span></span><br><span class="line">    ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">    System.out.println(parent);</span><br><span class="line">    <span class="comment">//获取扩展类加载器的父类加载器---&gt;根(引导类)加载器(c/c++),该加载器无法直接获取,所以输出的值为null</span></span><br><span class="line">    ClassLoader parent1 = parent.getParent();</span><br><span class="line">    System.out.println(parent1);</span><br><span class="line">    <span class="comment">//测试当前类是哪个加载器加载的</span></span><br><span class="line">    Class c1 = Class.forName(<span class="string">&quot;com.lhf_siven.Reflection.Test04&quot;</span>);</span><br><span class="line">    System.out.println(c1.getClassLoader());</span><br><span class="line">    <span class="comment">//测试Object类是哪个加载器加载的</span></span><br><span class="line">    System.out.println(Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">    sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">    sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>双亲委派机制：防止同名包、类与 jdk 中的相冲突，实际上加载类的时候，先通知 appLoader，看 appLoader 是否已经缓存，没有的话，appLoader 又委派给他的父类加载器(extLoader)询问，看他是不是能已经缓存加载,没有的话，extLoader 又委派他的父类加载器(bootstrapLoader)询问，BootstrapLoader看是不是自己已缓存或者能加载的，有就加载，没有再返回 extLoader，extLoader 能加载就加载，不能的话再返回给 appLoader 加载，再返回的路中，谁能加载，加载的同时也加缓存里。正是由于不停的找自己父级，所以才有 Parents 加载机制，翻译过来叫 双亲委派机制。 </li>
</ul>
<h4 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h4><p>通过反射获取运行时类的完整结构</p>
<p>Field、Method、Constructor、Superclass、Interface、Annotation</p>
<ul>
<li><p>实现的全部接口</p>
</li>
<li><p>所继承的父类</p>
</li>
<li><p>全部的构造器</p>
</li>
<li><p>全部的方法</p>
</li>
<li><p>全部的Field</p>
</li>
<li><p>注解</p>
</li>
<li><h6 id="……"><a href="#……" class="headerlink" title="……"></a>……</h6></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.lhf_siven.Reflection.User&quot;</span>);</span><br><span class="line">        <span class="comment">//获得类的名字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        System.out.println(c1.getName());   <span class="comment">//获得包名+类名</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">//获得类名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        <span class="comment">//获得类的属性</span></span><br><span class="line">        Field[] f1 = c1.getFields();    <span class="comment">//只能找到public属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : f1) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        Field[] df = c1.getDeclaredFields();    <span class="comment">//可以找到全部的属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : df) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        <span class="comment">//获得类的方法</span></span><br><span class="line">        Method[] m1 = c1.getMethods();<span class="comment">//获得本类及其父类的所有public方法,如果子类改写了父类的方法,那么只获得子类改写的.</span></span><br><span class="line">        Method[] dm = c1.getDeclaredMethods();<span class="comment">//获得本类的所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : m1) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method method : dm) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得指定方法</span></span><br><span class="line">        Method M1 = c1.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        System.out.println(M1);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        Class b1 = b.getClass();</span><br><span class="line">        Method[] BM1 = b1.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : BM1) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        <span class="comment">//获得指定的构造器</span></span><br><span class="line">        Constructor[] con1 = b1.getConstructors();  <span class="comment">//获得public的构造方法,编译器添加的空构造方法不在其范围内</span></span><br><span class="line">        Constructor[] dcon1 = b1.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : con1) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : dcon1) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        getFiled(),</span></span><br><span class="line"><span class="comment">        getDeclaredField(),</span></span><br><span class="line"><span class="comment">        getMethods(),</span></span><br><span class="line"><span class="comment">        getDeclaredMethod(),</span></span><br><span class="line"><span class="comment">        getConstructor(),</span></span><br><span class="line"><span class="comment">        getDeclaredConstructor(),</span></span><br><span class="line"><span class="comment">        获得指定的属性,方法,构造器,有无Declared的差别同上面的一致</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>在实际的操作中,取得类的信息的操作代码,并不会经常开发。</li>
<li>一定要熟悉java.lang.reflect包的作用，反射机制。</li>
<li>如何取得属性、方法、构造器的名称、修饰符等。</li>
</ul>
<h4 id="有了Class对象，能做什么？"><a href="#有了Class对象，能做什么？" class="headerlink" title="有了Class对象，能做什么？"></a>有了Class对象，能做什么？</h4><ul>
<li>创建类的对象：调用Class对象的newInstance()方法<ul>
<li>类必须有一个无参数的构造器</li>
<li>类的构造器的访问权限需要足够</li>
</ul>
</li>
<li><strong>思考</strong>难道没有无参的构造器就不能创建对象了吗？只有在操作的时候明确的调用类中的构造器，并将参数传递进去后，就可以实例化操作。</li>
<li>步骤如下：<ol>
<li>通过Class类的GetDeclaredConstructor(Class … parameterType)取得本类的指定形参类型的构造器</li>
<li>向构造器的形参中传递一个对象数组进去,里面包含了构造器中所需要的各个参数。</li>
<li>通过Constructor实例化对象。</li>
</ol>
</li>
</ul>
<h4 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h4><h5 id="调用指定的方法"><a href="#调用指定的方法" class="headerlink" title="调用指定的方法"></a>调用指定的方法</h5><p>通过反射，调用类中的方法，通过Method类完成。</p>
<ul>
<li><p>通过Class类的getMethod（String name，Class … parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</p>
</li>
<li><p>之后用Object invoke（Object obj，Object[] args) 进行调用,并向方法中传递要设置的obj对象的参数信息。</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201229234031916.png" alt="image-20201229234031916"></p>
</li>
<li><p>**Object invoke（Object obj，Object[] args) **</p>
<ul>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null。</li>
<li>若原方法为静态方法，此时形参Object obj可为null</li>
<li>若原方法形参列表位空，则Object[] args可谓null</li>
<li>若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法。</li>
</ul>
</li>
<li><p><strong>setAccessible</strong></p>
<ul>
<li>Method和Field、Constructor对象都有setAccessible()方法。</li>
<li>setAccessible()作用是启动和禁止访问安全检查的开关。</li>
<li>参数值为true则是表明反射对象在使用时应该取消Java语言访问检查。<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li>
<li>使得原本无法访问的私有成员也可以被访问</li>
<li>参数值为false则表示反射对象在使用时应强制进行Java语言访问检查。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射, 动态的创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">//获得Class对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.lhf_siven.Reflection.User&quot;</span>);</span><br><span class="line">        <span class="comment">//构造一个对象</span></span><br><span class="line">        User user  = (User)c1.newInstance();    <span class="comment">//本质上是调用了类的无参构造器</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过构造器创建对象</span></span><br><span class="line">        Constructor con1 = c1.getConstructor(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        User user1 = (User)con1.newInstance(<span class="string">&quot;name&quot;</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用普通方法</span></span><br><span class="line">        User user2 = (User)c1.newInstance();</span><br><span class="line">        <span class="comment">//通过反射获取一个方法</span></span><br><span class="line">        Method setName = c1.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//invoke: 激活 (Object,Object...args)</span></span><br><span class="line">        setName.invoke(user2,<span class="string">&quot;lhf&quot;</span>);</span><br><span class="line">        System.out.println(user2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射操作属性</span></span><br><span class="line">        User user3 = (User)c1.newInstance();</span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//设置反射对象在使用时是否进行java语言访问控制,值为true时不检查,因此即使是被private修饰的属性也可以访问到,</span></span><br><span class="line">        <span class="comment">// 值为false的时候,则强制检查.</span></span><br><span class="line">        <span class="comment">//不能直接操作私有属性,我们需要提前关闭程序的安全检测</span></span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(user3,<span class="string">&quot;siven&quot;</span>);</span><br><span class="line">        System.out.println(user3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="性能对比分析"><a href="#性能对比分析" class="headerlink" title="性能对比分析"></a>性能对比分析</h4><p>普通方式调用、反射方式调用、关闭检测的反射方式调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分析性能问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test07</span> </span>&#123;</span><br><span class="line">    <span class="comment">//普通方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通方式执行10亿次:&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user);</span><br><span class="line">        &#125;</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射方式执行10亿次:&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射方式调用,关闭检测</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        getName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射方式关闭检测执行10亿次:&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">        test03();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    普通方式执行10亿次:3ms</span></span><br><span class="line"><span class="comment">    反射方式执行10亿次:2475ms</span></span><br><span class="line"><span class="comment">    反射方式关闭检测执行10亿次:1795ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>经测试用反射来调用方法是要比直接用类来调用慢很多，而关闭检测则会让效率相对提高，但同样的会降低安全性，实际运用中在效率和安全上要做一个取舍。</strong></p>
<h4 id="反射操作泛型"><a href="#反射操作泛型" class="headerlink" title="反射操作泛型"></a>反射操作泛型</h4><ul>
<li>Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除。</li>
<li>为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的但是又和原始类型齐名的类型。</li>
<li>ParameterizedType：表示一种参数化类型，比如Collection<String></String></li>
<li>GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型。</li>
<li>TypeVariable：是各种类型变量的公共父接口。</li>
<li>WildcardType：代表一种通配符类型表达式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射获取泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,User&gt; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test02&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        Method method = Test08.class.getDeclaredMethod(&quot;test01&quot;, Map.class, List.class);</span><br><span class="line"></span><br><span class="line">        Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;#&quot;</span>+genericParameterType);</span><br><span class="line">            <span class="keyword">if</span>(genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;##&quot;</span>+actualTypeArgument);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method method2 = Test08.class.getDeclaredMethod(&quot;test02&quot;, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Type genericReturnType = method2.getGenericReturnType();</span><br><span class="line">        System.out.println(genericParameterTypes);</span><br><span class="line">        <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;!!&quot;</span>+actualTypeArgument);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #java.util.Map&lt;java.lang.String, com.lhf_siven.Reflection.User&gt;</span></span><br><span class="line"><span class="comment">    ##class java.lang.String</span></span><br><span class="line"><span class="comment">    ##class com.lhf_siven.Reflection.User</span></span><br><span class="line"><span class="comment">    #java.util.List&lt;com.lhf_siven.Reflection.User&gt;</span></span><br><span class="line"><span class="comment">    ##class com.lhf_siven.Reflection.User</span></span><br><span class="line"><span class="comment">    !java.util.Map&lt;java.lang.String, com.lhf_siven.Reflection.User&gt;</span></span><br><span class="line"><span class="comment">    !!class java.lang.String</span></span><br><span class="line"><span class="comment">    !!class com.lhf_siven.Reflection.User</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h4><ul>
<li>getAnnotations</li>
<li>getAnnotation</li>
</ul>
<h5 id="练习-ORM"><a href="#练习-ORM" class="headerlink" title="练习:ORM"></a>练习:ORM</h5><ul>
<li><p>了解什么是ORM?</p>
<ul>
<li><p>Object relationship Mapping –&gt; 对象关系映射</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201231213929030.png" alt="image-20201231213929030"></p>
</li>
<li><p>类和表结构对应</p>
</li>
<li><p>属性和字段对应</p>
</li>
<li><p>对象和记录对应</p>
</li>
</ul>
</li>
<li><p>要求：利用注解和反射完成类和表结构的映射关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhf_siven.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lhf_siven.demo.Outer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习反射操作注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class stu = Class.forName(<span class="string">&quot;com.lhf_siven.Reflection.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//通过反射获得类的注解</span></span><br><span class="line">        Annotation[] annotations = stu.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得注解的value</span></span><br><span class="line">        TableSiven annotation = (TableSiven)stu.getAnnotation(TableSiven.class);</span><br><span class="line">        System.out.println(annotation.value());</span><br><span class="line">        <span class="comment">//获得类字段的注解</span></span><br><span class="line">        Field name = stu.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        FieldSiven annotation1 = (FieldSiven)name.getAnnotation(FieldSiven.class);</span><br><span class="line">        System.out.println(annotation1.columnName()+<span class="string">&quot; &quot;</span>+annotation1.type()+<span class="string">&quot; &quot;</span>+annotation1.length());</span><br><span class="line">        Field id = stu.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        FieldSiven annotation2 = (FieldSiven)id.getAnnotation(FieldSiven.class);</span><br><span class="line">        System.out.println(annotation2.columnName()+<span class="string">&quot; &quot;</span>+annotation2.type()+<span class="string">&quot; &quot;</span>+annotation2.length());</span><br><span class="line">        Field age = stu.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        FieldSiven annotation3 = (FieldSiven)age.getAnnotation(FieldSiven.class);</span><br><span class="line">        System.out.println(annotation3.columnName()+<span class="string">&quot; &quot;</span>+annotation3.type()+<span class="string">&quot; &quot;</span>+annotation3.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@TableSiven(&quot;db_student&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="meta">@FieldSiven(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 12)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@FieldSiven(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@FieldSiven(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 3)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> TableSiven&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//属性的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FieldSiven&#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @com.lhf_siven.Reflection.TableSiven(value=db_student)</span></span><br><span class="line"><span class="comment">    db_student</span></span><br><span class="line"><span class="comment">    db_name varchar 3</span></span><br><span class="line"><span class="comment">    db_id int 12</span></span><br><span class="line"><span class="comment">    db_age int 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h4 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h4><ul>
<li><p>JVM的位置</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/20200325111818566.png" alt="在这里插入图片描述"></p>
</li>
<li></li>
</ul>
<h3 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h3><h3 id="字节码与类的加载"><a href="#字节码与类的加载" class="headerlink" title="字节码与类的加载"></a>字节码与类的加载</h3><h3 id="性能监控与调优"><a href="#性能监控与调优" class="headerlink" title="性能监控与调优"></a>性能监控与调优</h3><h3 id="大厂面试"><a href="#大厂面试" class="headerlink" title="大厂面试"></a>大厂面试</h3><h4 id="毕业设计"><a href="#毕业设计" class="headerlink" title="毕业设计"></a>毕业设计</h4><p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208101126683.png" alt="image-20201208101126683"></p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208102041319.png" alt="image-20201208102041319"></p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208102205677.png" alt="image-20201208102205677"></p>
<p>近三年的文献不能少于40%,尽量多</p>
<p><img src="/2020/09/22/java%E5%AD%A6%E4%B9%A0/image-20201208102444709.png" alt="image-20201208102444709"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-16 08:46:00" itemprop="dateCreated datePublished" datetime="2020-09-16T08:46:00+08:00">2020-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-27 15:38:04" itemprop="dateModified" datetime="2020-09-27T15:38:04+08:00">2020-09-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><ul>
<li>进程是系统分配资源的最小单位,而线程是cpu调度的最小单位.</li>
<li>一个进程可以拥有多个线程,这些线程可以并发执行,并共享进程的一些公共资源,同时它们也拥有自己的栈空间,拥有对了的执行队列.</li>
<li></li>
</ul>
<h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justloveyou_/article/details/78304294">https://blog.csdn.net/justloveyou_/article/details/78304294</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/inception6-lxc/p/9073983.html">https://www.cnblogs.com/inception6-lxc/p/9073983.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-16 08:45:22" itemprop="dateCreated datePublished" datetime="2020-09-16T08:45:22+08:00">2020-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-09 17:57:36" itemprop="dateModified" datetime="2020-10-09T17:57:36+08:00">2020-10-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="mac地址和ip地址"><a href="#mac地址和ip地址" class="headerlink" title="mac地址和ip地址"></a>mac地址和ip地址</h4><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>答:OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。<br>每一层的协议如下：<br>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br>每一层的作用如下：<br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/09/%E5%B8%B8%E8%A7%81%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/09/%E5%B8%B8%E8%A7%81%E9%A2%98/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-09 22:09:28" itemprop="dateCreated datePublished" datetime="2020-09-09T22:09:28+08:00">2020-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-10 19:18:27" itemprop="dateModified" datetime="2020-09-10T19:18:27+08:00">2020-09-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="组合-combination"><a href="#组合-combination" class="headerlink" title="组合(combination)"></a>组合(combination)</h4><hr>
<h5 id="C-n-k"><a href="#C-n-k" class="headerlink" title="C(n,k)"></a>C(n,k)</h5><p>递归:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    n个数中求k个数的组合,这可以用递归来做.</span></span><br><span class="line"><span class="comment">    这个组合可以拆分成两个部分:包含第一个元素和不包含第一个元素</span></span><br><span class="line"><span class="comment">    这就意味着:f(n,k) = f(n-1,k-1)+f(n-1,k)</span></span><br><span class="line"><span class="comment">    这实际上就是我们高中学过的C(n,k) = C(n-1,k)+C(n-1,k-1)</span></span><br><span class="line"><span class="comment">    这就是我们的递归式子.</span></span><br><span class="line"><span class="comment">    当然停止条件有两个一个是当n==k时,返回这n个数,另一个是k==0时,返回空集。</span></span><br><span class="line"><span class="comment">    为什么会有k==0的情况呢？</span></span><br><span class="line"><span class="comment">    假设n&gt;k，那么随着递归的深入，必然会出现调用f（k+1，k），那么根据递归公式，会分别调用f（k，k）和f（k，k-1）</span></span><br><span class="line"><span class="comment">    由此可见，f（k，k）达到了停止条件，而f（k，k-1）就跟刚才的f（k+1，k）一般还要继续调递归下去，直到k-1==0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//伪代码    beg，ed对应我们将组合的数字在容器的下标区间</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> beg,<span class="keyword">int</span> ed,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;    <span class="comment">//注意是&#123;&#123;&#125;&#125;而不是&#123;&#125;。</span></span><br><span class="line">    <span class="keyword">if</span>（ed-beg+<span class="number">1</span> == k)&#123;把对应的数放到res中；<span class="keyword">return</span>  res;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         res = dfs(beg+<span class="number">1</span>,ed,k);<span class="comment">//不包含第一个元素</span></span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; temp = dfs(beg+<span class="number">1</span>,ed,k<span class="number">-1</span>)<span class="comment">//包含第一个元素</span></span><br><span class="line">         把beg对应的数加入道temp中每个<span class="built_in">vector</span>；</span><br><span class="line">         把temp中的元素加入到res；</span><br><span class="line">         <span class="keyword">return</span> res；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面这串代码的空间复杂度和时间复杂度都比较高,我们试着换种思路.</span></span><br></pre></td></tr></table></figure>

<p>回溯法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    从n个数中求k个数,那么每个数的就有两种选择:选或不选,那么我们通过回溯法来把所有可能都走一遍.就能得到结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> beg, <span class="keyword">int</span> ed, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size()+ed-beg+<span class="number">1</span>&lt;k)&#123;<span class="keyword">return</span> ;&#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.size()==k)&#123;res.push_back(temp);<span class="keyword">return</span> ;&#125;</span><br><span class="line">        temp.push_back(beg);</span><br><span class="line">        dfs(beg+<span class="number">1</span>,ed,k); <span class="comment">//包含该数</span></span><br><span class="line">        temp.pop_back();<span class="comment">//回溯法的关键步骤,记得要恢复原来状态</span></span><br><span class="line">        dfs(beg+<span class="number">1</span>,ed,k); <span class="comment">//不包含该数.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>非递归(字典序法)实现组合型枚举</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    上面两种算法本质都是递归,而这意味着我们需要付出一部分内存用于栈中.</span></span><br><span class="line"><span class="comment">    我们不希望有这么一部分开销,那么有没有什么算法可以不用递归,直接在combine()函数中得到结果呢?</span></span><br><span class="line"><span class="comment">    是有的.</span></span><br><span class="line"><span class="comment">    我们将n个数按从小到大排列,每个数有两种选项选和不选,选中为1,不选中为k</span></span><br><span class="line"><span class="comment">    那么从n个数中找出k个数就可以用一个包含k个1,(n-k)个0的二进制数表示,例如从1234中选出2个数.</span></span><br><span class="line"><span class="comment">    4    3    [2]    [1]    0011</span></span><br><span class="line"><span class="comment">    4    [3]    2    [1]    0101</span></span><br><span class="line"><span class="comment">    4    [3]    [2]    1    0110</span></span><br><span class="line"><span class="comment">    [4]    3    2    [1]    1001</span></span><br><span class="line"><span class="comment">    [4]    3    [2]    1    1010</span></span><br><span class="line"><span class="comment">    [4]    [3]    2    1    1100</span></span><br><span class="line"><span class="comment">    可以看出这些选项是按照一定字典序排列的，我们要找到一种规则，能够根据当前组合去找到对应字典里的下一个字典，而这规则如下：</span></span><br><span class="line"><span class="comment">    假设某组合i末尾有j（0&lt;=j&lt;=n-k)个0,然后第j个0前面是m(1&lt;=m&lt;=k)个连续的1</span></span><br><span class="line"><span class="comment">    那么他的下一个组合形式如下:</span></span><br><span class="line"><span class="comment">    将第m+j个1跟第m+j+1的0调转位置,然后将第j+1倒第m+j-1的1移到最后</span></span><br><span class="line"><span class="comment">    说通俗点**就是将那m个1,把打头的那个1跟前面的0交换,然后把剩下的1放倒最后**</span></span><br><span class="line"><span class="comment">    为什么一定是这样?那是因为我们要搞清楚i的下一个组合对应的二进制一定要比i大,且要离他最近,因为1的数字是有限的,所以我们不</span></span><br><span class="line"><span class="comment">    能通过在末尾0上加一来获得一个比i大的二进制,唯一能做的就是让打头的那个1向前一位,然后要求是离i最近,这意味着要将剩下的1</span></span><br><span class="line"><span class="comment">    放到末尾,这样才能保证最近,举例:</span></span><br><span class="line"><span class="comment">    0011→0101    0101→0110    1001→1010</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//代码实现:</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        上面的思想怎么实现代码呢?</span></span><br><span class="line"><span class="comment">        我们知道,通常n是很大的,而k是很小的,我们我们存储的时候自然存储的是那k个数</span></span><br><span class="line"><span class="comment">        而上述算法中从i变到i+1有两个步骤</span></span><br><span class="line"><span class="comment">        找到连续连续m个1</span></span><br><span class="line"><span class="comment">        将打头的1前进一步,将后面剩下的1放到最后.</span></span><br><span class="line"><span class="comment">        我们的实现做法是:</span></span><br><span class="line"><span class="comment">        用一个vector存储&#123;a0,a1,...,a(k-1)&#125;</span></span><br><span class="line"><span class="comment">        当aj + 1 != a(j+1)时这意味着这两个数对应的两个1中存在0,相同的当aj + 1 = a(j+1)时,意味着连续的1</span></span><br><span class="line"><span class="comment">        因此,当我们第一次遇到aj + 1 != a(j+1)时就意味着aj就是打头的那个1,我们只要使得aj = aj+1就可以实现1向前</span></span><br><span class="line"><span class="comment">        进1位的操作.</span></span><br><span class="line"><span class="comment">        而将余下的1放到最后,这一点我们可以在发现aj+1 = a(j+1)时,直接让aj = j+1(因为j是从0开始的,所以要加一).</span></span><br><span class="line"><span class="comment">        那么这样我们就实现了上面所说的如何根据i得到i+1组合的算法</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        除此之外还有一个关键点就是当a0,a1,...a(k-1)都是连续的数的时候,那么aj显然就是a(k-1)了,那么为了让程序能够执行下去</span></span><br><span class="line"><span class="comment">        我们必须在vector中再添加一个哨兵,他的值为n+1.这个哨兵一方面能够让a(k-1)的值不断增加,另一方面能够作为程序终止的</span></span><br><span class="line"><span class="comment">        条件,当a0,a1...,a(k-1)为n个数中最大的k个数,这意味着我们的字典走到了最后,此时应该是程序终止的时刻,这种情况下满足</span></span><br><span class="line"><span class="comment">        了a(k-1)+1 = n+1 的情况,使得j首次进入了k,所以我们只需要判断j是否等于k就能控制程序的终止了.</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        程序如下:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=k;x++)</span><br><span class="line">            temp.push_back(x);</span><br><span class="line">        temp.push_back(n+<span class="number">1</span>);<span class="comment">//添加哨兵</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;k)&#123;<span class="comment">//emplace_back比push_back少一步拷贝,直接拿参数原地构建对象.</span></span><br><span class="line">            res.emplace_back(temp.begin(), temp.begin() + k);</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k&amp;&amp;temp[j]+<span class="number">1</span> == temp[j+<span class="number">1</span>])&#123;    <span class="comment">//当j=k-1,且temp[j]=n时,j才可能变成k,程序终止.而一旦j满足前面</span></span><br><span class="line">                                                <span class="comment">//两个条件,意味着temp中k个数已经是n中最大的k个数,是字典中最后一个</span></span><br><span class="line">                                                <span class="comment">//组合,程序理应终止.</span></span><br><span class="line">                temp[j] = j+<span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            temp[j]++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/07/%E7%AE%80%E5%8E%86%E5%9F%B9%E8%AE%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhf_siven">
      <meta itemprop="description" content="努力变成更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhf_siven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/07/%E7%AE%80%E5%8E%86%E5%9F%B9%E8%AE%AD/" class="post-title-link" itemprop="url">简历培训</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-07 19:05:33 / 修改时间：19:46:50" itemprop="dateCreated datePublished" datetime="2020-09-07T19:05:33+08:00">2020-09-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="好简历的金标准"><a href="#好简历的金标准" class="headerlink" title="好简历的金标准"></a>好简历的金标准</h4><ol>
<li>内容：针对应聘岗位</li>
<li>措辞：具体、简洁、条例<ul>
<li>动作分解</li>
<li>动宾结构</li>
<li>添加数字</li>
</ul>
</li>
<li>模板：商务、易于阅读</li>
</ol>
<img src="/2020/09/07/%E7%AE%80%E5%8E%86%E5%9F%B9%E8%AE%AD/image-20200907194642837.png" alt="image-20200907194642837" style="zoom:50%;">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lhf_siven</p>
  <div class="site-description" itemprop="description">努力变成更好的自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/siven1987" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;siven1987" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lhf_siven@qq.com" title="E-Mail → mailto:lhf_siven@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lhf_siven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>-->
